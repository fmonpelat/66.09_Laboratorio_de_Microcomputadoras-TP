
GPS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000027e  00800100  000008b6  0000094a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000008b6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000a  0080037e  0080037e  00000bc8  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000bc8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000bf8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000e8  00000000  00000000  00000c38  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000e25  00000000  00000000  00000d20  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000712  00000000  00000000  00001b45  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000013ee  00000000  00000000  00002257  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000d4  00000000  00000000  00003648  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000003f6  00000000  00000000  0000371c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000074f  00000000  00000000  00003b12  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000038  00000000  00000000  00004261  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
   8:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
   c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  10:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  14:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  18:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  1c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  20:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  24:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  28:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  2c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  30:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  34:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  38:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  3c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  40:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  44:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  48:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  4c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  50:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  54:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  58:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  5c:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  60:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>
  64:	0c 94 46 00 	jmp	0x8c	; 0x8c <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_clear_bss>:
  74:	23 e0       	ldi	r18, 0x03	; 3
  76:	ae e7       	ldi	r26, 0x7E	; 126
  78:	b3 e0       	ldi	r27, 0x03	; 3
  7a:	01 c0       	rjmp	.+2      	; 0x7e <.do_clear_bss_start>

0000007c <.do_clear_bss_loop>:
  7c:	1d 92       	st	X+, r1

0000007e <.do_clear_bss_start>:
  7e:	a8 38       	cpi	r26, 0x88	; 136
  80:	b2 07       	cpc	r27, r18
  82:	e1 f7       	brne	.-8      	; 0x7c <.do_clear_bss_loop>
  84:	0e 94 ea 00 	call	0x1d4	; 0x1d4 <main>
  88:	0c 94 59 04 	jmp	0x8b2	; 0x8b2 <_exit>

0000008c <__bad_interrupt>:
  8c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000090 <DELAY1S>:
// ******************************************************************
//  DELAYS
//	No son exactos
// ******************************************************************
DELAY1S:
	push	TEMP
  90:	0f 93       	push	r16
	ldi		TEMP,10
  92:	0a e0       	ldi	r16, 0x0A	; 10

00000094 <LOOP1S>:
LOOP1S:
	rcall	DELAY100MS
  94:	04 d0       	rcall	.+8      	; 0x9e <DELAY100MS>
	dec		TEMP
  96:	0a 95       	dec	r16
	brne	LOOP1S
  98:	e9 f7       	brne	.-6      	; 0x94 <LOOP1S>
	pop		TEMP
  9a:	0f 91       	pop	r16
	ret
  9c:	08 95       	ret

0000009e <DELAY100MS>:
// ******************************************************************
DELAY100MS:
	push	TEMP
  9e:	0f 93       	push	r16
	ldi		TEMP,101
  a0:	05 e6       	ldi	r16, 0x65	; 101

000000a2 <LOOP100MS>:
LOOP100MS:
	rcall	DELAY1MS
  a2:	0b d0       	rcall	.+22     	; 0xba <DELAY1MS>
	dec		TEMP
  a4:	0a 95       	dec	r16
	brne	LOOP100MS
  a6:	e9 f7       	brne	.-6      	; 0xa2 <LOOP100MS>
	pop		TEMP
  a8:	0f 91       	pop	r16
	ret
  aa:	08 95       	ret

000000ac <DELAY10MS>:
// ******************************************************************
DELAY10MS:
	push	TEMP
  ac:	0f 93       	push	r16
	ldi		TEMP,11
  ae:	0b e0       	ldi	r16, 0x0B	; 11

000000b0 <LOOP10MS>:
LOOP10MS:
	rcall	DELAY1MS
  b0:	04 d0       	rcall	.+8      	; 0xba <DELAY1MS>
	dec		TEMP
  b2:	0a 95       	dec	r16
	brne	LOOP10MS
  b4:	e9 f7       	brne	.-6      	; 0xb0 <LOOP10MS>
	pop		TEMP
  b6:	0f 91       	pop	r16
	ret
  b8:	08 95       	ret

000000ba <DELAY1MS>:
// ******************************************************************
DELAY1MS:
	push	TEMP2
  ba:	1f 93       	push	r17
	push	TEMP
  bc:	0f 93       	push	r16
	ldi		TEMP2, 21
  be:	15 e1       	ldi	r17, 0x15	; 21
	ldi		TEMP, 197
  c0:	05 ec       	ldi	r16, 0xC5	; 197

000000c2 <LOOP1MS>:
LOOP1MS:
	dec		TEMP
  c2:	0a 95       	dec	r16
	brne	LOOP1MS
  c4:	f1 f7       	brne	.-4      	; 0xc2 <LOOP1MS>
	dec		TEMP2
  c6:	1a 95       	dec	r17
	brne	LOOP1MS
  c8:	e1 f7       	brne	.-8      	; 0xc2 <LOOP1MS>
	pop		TEMP
  ca:	0f 91       	pop	r16
	pop		TEMP2
  cc:	1f 91       	pop	r17
  ce:	08 95       	ret

000000d0 <LCD_init>:
// LCD_init: Inicializa el LCD 
//parametros de entrada: Ninguno
//parametros de salida: Ninguno
// ******************************************************************
LCD_init:  
	push	TEMP
  d0:	0f 93       	push	r16

	//borro el puerto de datos y control
	cbi		LCD_DATPORT,LCD_D4
  d2:	5c 98       	cbi	0x0b, 4	; 11
	cbi		LCD_DATPORT,LCD_D5
  d4:	5d 98       	cbi	0x0b, 5	; 11
	cbi		LCD_DATPORT,LCD_D6
  d6:	5e 98       	cbi	0x0b, 6	; 11
	cbi		LCD_DATPORT,LCD_D7
  d8:	5f 98       	cbi	0x0b, 7	; 11
	cbi		LCD_CTRPORT,LCD_E
  da:	42 98       	cbi	0x08, 2	; 8
	cbi		LCD_CTRPORT,LCD_RW
  dc:	41 98       	cbi	0x08, 1	; 8
	cbi		LCD_CTRPORT,LCD_RS
  de:	40 98       	cbi	0x08, 0	; 8
	//datos y control como salida
	sbi		LCD_DATDDR,LCD_D4
  e0:	54 9a       	sbi	0x0a, 4	; 10
	sbi		LCD_DATDDR,LCD_D5
  e2:	55 9a       	sbi	0x0a, 5	; 10
	sbi		LCD_DATDDR,LCD_D6
  e4:	56 9a       	sbi	0x0a, 6	; 10
	sbi		LCD_DATDDR,LCD_D7
  e6:	57 9a       	sbi	0x0a, 7	; 10
	sbi		LCD_CTRDDR,LCD_E
  e8:	3a 9a       	sbi	0x07, 2	; 7
	sbi		LCD_CTRDDR,LCD_RW
  ea:	39 9a       	sbi	0x07, 1	; 7
	sbi		LCD_CTRDDR,LCD_RS
  ec:	38 9a       	sbi	0x07, 0	; 7
	//inicializo el LCD como indica la datasheet
	sbi     LCD_DATPORT,LCD_D6
  ee:	5e 9a       	sbi	0x0b, 6	; 11
	sbi     LCD_DATPORT,LCD_D7
  f0:	5f 9a       	sbi	0x0b, 7	; 11
	rcall   LCD_PulsoEnable			//Pulso E
  f2:	59 d0       	rcall	.+178    	; 0x1a6 <LCD_PulsoEnable>
	rcall	DELAY10MS
  f4:	db df       	rcall	.-74     	; 0xac <DELAY10MS>
	rcall	LCD_PulsoEnable			//Pulso E
  f6:	57 d0       	rcall	.+174    	; 0x1a6 <LCD_PulsoEnable>
	rcall	DELAY10MS
  f8:	d9 df       	rcall	.-78     	; 0xac <DELAY10MS>
	rcall	LCD_PulsoEnable			//Pulso E
  fa:	55 d0       	rcall	.+170    	; 0x1a6 <LCD_PulsoEnable>
	rcall	DELAY10MS
  fc:	d7 df       	rcall	.-82     	; 0xac <DELAY10MS>
	ldi		TEMP, LCD_FUNC_SET		//Comando FUNCION SET
  fe:	0c e2       	ldi	r16, 0x2C	; 44
	rcall	LCD_EnviarCmd
 100:	22 d0       	rcall	.+68     	; 0x146 <LCD_EnviarCmd>
	ldi		TEMP, LCD_CURS_SHIFT	//Comando CURSOR SHIFT
 102:	04 e1       	ldi	r16, 0x14	; 20
	rcall	LCD_EnviarCmd
 104:	20 d0       	rcall	.+64     	; 0x146 <LCD_EnviarCmd>
	ldi		TEMP, LCD_DISP_ON		//Comando DISPLAY ON OFF
 106:	0c e0       	ldi	r16, 0x0C	; 12
	rcall	LCD_EnviarCmd
 108:	1e d0       	rcall	.+60     	; 0x146 <LCD_EnviarCmd>
	ldi		TEMP, LCD_ENTRY_MODE	//Comando LCD ENTRY MODE
 10a:	06 e0       	ldi	r16, 0x06	; 6
	rcall	LCD_EnviarCmd
 10c:	1c d0       	rcall	.+56     	; 0x146 <LCD_EnviarCmd>
	rcall	LCD_Borrar				//Borrar LCD
 10e:	14 d0       	rcall	.+40     	; 0x138 <LCD_Borrar>

	pop		TEMP
 110:	0f 91       	pop	r16
	ret
 112:	08 95       	ret

00000114 <LCD_ImprimirString>:
// encontrarse con 0
//parametros de entrada:  Z - string
//parametros de salida: Ninguno
// ******************************************************************
LCD_ImprimirString:
	push	TEMP
 114:	0f 93       	push	r16
	push    TEMP2
 116:	1f 93       	push	r17
	push	ZH
 118:	ff 93       	push	r31
	push	ZL
 11a:	ef 93       	push	r30

	ldi		TEMP2,0
 11c:	10 e0       	ldi	r17, 0x00	; 0

0000011e <LCD_ImprimirLoop>:
LCD_ImprimirLoop: 
	lpm		TEMP,Z+				// Carga el contenido de Z en TEMP
 11e:	05 91       	lpm	r16, Z+
	inc		TEMP2
 120:	13 95       	inc	r17
	cpi		TEMP2,16
 122:	10 31       	cpi	r17, 0x10	; 16
	breq	EXIT_PRINT
 124:	21 f0       	breq	.+8      	; 0x12e <EXIT_PRINT>
	tst		TEMP				// Resto 1 al contador de string
 126:	00 23       	and	r16, r16
	breq EXIT_PRINT
 128:	11 f0       	breq	.+4      	; 0x12e <EXIT_PRINT>
	rcall	LCD_EnviarChar		// Envio Caracter
 12a:	24 d0       	rcall	.+72     	; 0x174 <LCD_EnviarChar>
	rjmp	LCD_ImprimirLoop
 12c:	f8 cf       	rjmp	.-16     	; 0x11e <LCD_ImprimirLoop>

0000012e <EXIT_PRINT>:
    EXIT_PRINT:

	pop		ZL
 12e:	ef 91       	pop	r30
	pop		ZH
 130:	ff 91       	pop	r31
	pop		TEMP2
 132:	1f 91       	pop	r17
	pop		TEMP
 134:	0f 91       	pop	r16
	ret
 136:	08 95       	ret

00000138 <LCD_Borrar>:
// LCD_Borrar: Borra el contenido del display y pone el cursor en home
//parametros de entrada:  Z - string
//parametros de salida: Ninguno
// ******************************************************************
LCD_Borrar:   
	push	TEMP
 138:	0f 93       	push	r16

	ldi		TEMP, LCD_CLEAR_DISP
 13a:	01 e0       	ldi	r16, 0x01	; 1
	rcall	LCD_EnviarCmd
 13c:	04 d0       	rcall	.+8      	; 0x146 <LCD_EnviarCmd>
	ldi		TEMP, LCD_CURS_HOME
 13e:	02 e0       	ldi	r16, 0x02	; 2
	rcall	LCD_EnviarCmd
 140:	02 d0       	rcall	.+4      	; 0x146 <LCD_EnviarCmd>

	pop		TEMP
 142:	0f 91       	pop	r16
	ret
 144:	08 95       	ret

00000146 <LCD_EnviarCmd>:
//LCD_EnviarCmd: Envia el elegido comando al display
//parametros de entrada:  TEMP - Comando
//parametros de salida: Ninguno
// ******************************************************************
LCD_EnviarCmd:   
	push	TEMP
 146:	0f 93       	push	r16
	push	TEMP2
 148:	1f 93       	push	r17
	push	TEMP3
 14a:	9f 93       	push	r25

	rcall   DELAY10MS			// se crea un delay para no probar si el lcd se encuentra ocupado
 14c:	af df       	rcall	.-162    	; 0xac <DELAY10MS>
	mov		TEMP2, TEMP			// Se utilizan mascaras para no pisar los datos del puerto 
 14e:	10 2f       	mov	r17, r16
	andi	TEMP2, 0xF0			// que no son del LCD.
 150:	10 7f       	andi	r17, 0xF0	; 240
	in		TEMP3, LCD_DATPORT	
 152:	9b b1       	in	r25, 0x0b	; 11
	andi	TEMP3, 0x0F
 154:	9f 70       	andi	r25, 0x0F	; 15
	or		TEMP2,TEMP3
 156:	19 2b       	or	r17, r25
	out		LCD_DATPORT,TEMP2	//Se manda el primer nibble
 158:	1b b9       	out	0x0b, r17	; 11
	rcall	LCD_PulsoEnable		//Pulso enable
 15a:	25 d0       	rcall	.+74     	; 0x1a6 <LCD_PulsoEnable>
	swap	TEMP				//Se hace lo mismo que antes pero con los nibbles intercambiados
 15c:	02 95       	swap	r16
	mov		TEMP2, TEMP
 15e:	10 2f       	mov	r17, r16
	andi	TEMP2, 0xF0
 160:	10 7f       	andi	r17, 0xF0	; 240
	in		TEMP3, LCD_DATPORT
 162:	9b b1       	in	r25, 0x0b	; 11
	andi	TEMP3, 0x0F
 164:	9f 70       	andi	r25, 0x0F	; 15
	or		TEMP2,TEMP3
 166:	19 2b       	or	r17, r25
	out		LCD_DATPORT,TEMP2
 168:	1b b9       	out	0x0b, r17	; 11
	rcall	LCD_PulsoEnable		//Pulso enable
 16a:	1d d0       	rcall	.+58     	; 0x1a6 <LCD_PulsoEnable>

	pop		TEMP3
 16c:	9f 91       	pop	r25
	pop		TEMP2
 16e:	1f 91       	pop	r17
	pop		TEMP
 170:	0f 91       	pop	r16
	ret
 172:	08 95       	ret

00000174 <LCD_EnviarChar>:
// LCD_EnviarChar: Envia el caracter elegido al display
//parametros de entrada:  TEMP - Char
//parametros de salida: Ninguno
// ******************************************************************
LCD_EnviarChar:
	push	TEMP
 174:	0f 93       	push	r16
	push	TEMP2
 176:	1f 93       	push	r17
	push	TEMP3
 178:	9f 93       	push	r25

	rcall	DELAY10MS				// se crea un delay para no probar si el lcd se encuentra ocupado
 17a:	98 df       	rcall	.-208    	; 0xac <DELAY10MS>
	sbi		LCD_CTRPORT,LCD_RS		// RS ON: Escritura de DRAM Habilitada
 17c:	40 9a       	sbi	0x08, 0	; 8
	mov		TEMP2, TEMP				// Se utilizan mascaras para no pisar los datos del puerto 
 17e:	10 2f       	mov	r17, r16
	andi	TEMP2, 0xF0				// que no son del LCD.
 180:	10 7f       	andi	r17, 0xF0	; 240
	in		TEMP3, LCD_DATPORT		
 182:	9b b1       	in	r25, 0x0b	; 11
	andi	TEMP3, 0x0F
 184:	9f 70       	andi	r25, 0x0F	; 15
	or		TEMP2,TEMP3
 186:	19 2b       	or	r17, r25
	out		LCD_DATPORT,TEMP2		//Se manda el primer nibble
 188:	1b b9       	out	0x0b, r17	; 11
	rcall	LCD_PulsoEnable			//Pulso enable
 18a:	0d d0       	rcall	.+26     	; 0x1a6 <LCD_PulsoEnable>
	swap	TEMP					//Se hace lo mismo que antes pero con los nibbles intercambiados
 18c:	02 95       	swap	r16
	mov		TEMP2, TEMP
 18e:	10 2f       	mov	r17, r16
	andi	TEMP2, 0xF0
 190:	10 7f       	andi	r17, 0xF0	; 240
	in		TEMP3, LCD_DATPORT
 192:	9b b1       	in	r25, 0x0b	; 11
	andi	TEMP3, 0x0F
 194:	9f 70       	andi	r25, 0x0F	; 15
	or		TEMP2,TEMP3
 196:	19 2b       	or	r17, r25
	out		LCD_DATPORT,TEMP2
 198:	1b b9       	out	0x0b, r17	; 11
	rcall	LCD_PulsoEnable			//Pulso enable
 19a:	05 d0       	rcall	.+10     	; 0x1a6 <LCD_PulsoEnable>
	cbi		LCD_CTRPORT,LCD_RS		//RS OFF: Escritura de DRAM Deshabilitada
 19c:	40 98       	cbi	0x08, 0	; 8

	pop		TEMP3
 19e:	9f 91       	pop	r25
	pop		TEMP2
 1a0:	1f 91       	pop	r17
	pop		TEMP
 1a2:	0f 91       	pop	r16
	ret
 1a4:	08 95       	ret

000001a6 <LCD_PulsoEnable>:
// LCD_PulsoEnable: Envia un pulso a la pata E del LCD 
//parametros de entrada: Ninguno
//parametros de salida: Ninguno
// ******************************************************************
LCD_PulsoEnable:   
	sbi   	LCD_CTRPORT, LCD_E	//Enable SET
 1a6:	42 9a       	sbi	0x08, 2	; 8
	rcall	DELAY2NOP
 1a8:	02 d0       	rcall	.+4      	; 0x1ae <DELAY2NOP>
    cbi   	LCD_CTRPORT, LCD_E	//Enable CLEAR
 1aa:	42 98       	cbi	0x08, 2	; 8
    RET
 1ac:	08 95       	ret

000001ae <DELAY2NOP>:

// ******************************************************************	
// Delay de 2 Nops para mandar pulsos cortos (CLK: 16 MHZ ---> 2 micro segundos)
DELAY2NOP:
	nop
 1ae:	00 00       	nop
	nop
 1b0:	00 00       	nop
	RET
 1b2:	08 95       	ret

000001b4 <sd_wrerror>:
 1b4:	53 44       	sbci	r21, 0x43	; 67
 1b6:	20 57       	subi	r18, 0x70	; 112
 1b8:	72 69       	ori	r23, 0x92	; 146
 1ba:	74 65       	ori	r23, 0x54	; 84
 1bc:	20 65       	ori	r18, 0x50	; 80
 1be:	72 72       	andi	r23, 0x22	; 34
 1c0:	6f 72       	andi	r22, 0x2F	; 47
	...

000001c3 <sd_outofmem>:
 1c3:	53 44       	sbci	r21, 0x43	; 67
 1c5:	20 6f       	ori	r18, 0xF0	; 240
 1c7:	75 74       	andi	r23, 0x45	; 69
 1c9:	20 6f       	ori	r18, 0xF0	; 240
 1cb:	66 20       	and	r6, r6
 1cd:	6d 65       	ori	r22, 0x5D	; 93
 1cf:	6d 6f       	ori	r22, 0xFD	; 253
 1d1:	72 79       	andi	r23, 0x92	; 146
	...

000001d4 <main>:
/******************************************************************/
/******************************************************************/
// main: Where main program starts
/******************************************************************/
main:
	rcall	DELAY100MS			//Voltage stabilization time
 1d4:	64 df       	rcall	.-312    	; 0x9e <DELAY100MS>
	rcall	initializations
 1d6:	2b d0       	rcall	.+86     	; 0x22e <initializations>
	rcall	GPS_getString		// Get UBX String from GPS
 1d8:	aa d1       	rcall	.+852    	; 0x52e <GPS_getString>
	rcall	GPS_getString		// Get UBX String from GPS
 1da:	a9 d1       	rcall	.+850    	; 0x52e <GPS_getString>
	rcall	GPS_getString		// Get UBX String from GPS
 1dc:	a8 d1       	rcall	.+848    	; 0x52e <GPS_getString>
	rcall	GPS_getString		// Get UBX String from GPS
 1de:	a7 d1       	rcall	.+846    	; 0x52e <GPS_getString>
	rcall	GPS_getString		// Get UBX String from GPS
 1e0:	a6 d1       	rcall	.+844    	; 0x52e <GPS_getString>
	rcall	GPS_getString		// Get UBX String from GPS
 1e2:	a5 d1       	rcall	.+842    	; 0x52e <GPS_getString>

000001e4 <loop>:
// loop: Where the program loops forever
/******************************************************************/
loop:
//	rcall	bufferSDErase
//	rcall	bufferGPSErase
	ldi		COUNTER,4			//number of UBX strings stored in one sector
 1e4:	34 e0       	ldi	r19, 0x04	; 4
	ldi		YH,hi8(buffer_sd)
 1e6:	d1 e0       	ldi	r29, 0x01	; 1
	ldi		YL,lo8(buffer_sd)
 1e8:	c0 e0       	ldi	r28, 0x00	; 0

000001ea <SD_Loop_SaveData>:
SD_Loop_SaveData:
	rcall	GPS_getString		// Get UBX String from GPS
 1ea:	a1 d1       	rcall	.+834    	; 0x52e <GPS_getString>
	rcall	LCD_printLine1		// Print relevant data to the 1st line of LCD
 1ec:	5f d0       	rcall	.+190    	; 0x2ac <LCD_printLine1>
	rcall	LCD_printLine2		// Print relevant data to the 2nd line of LCD
 1ee:	a6 d0       	rcall	.+332    	; 0x33c <LCD_printLine2>
	rcall	GPS_lookForFix		// Check for fix
 1f0:	b6 d1       	rcall	.+876    	; 0x55e <GPS_lookForFix>
	cpi		ANS,0				// IF there is fix, then save the data
 1f2:	80 30       	cpi	r24, 0x00	; 0
	brne	SD_Loop_SaveData	// IF not, check again
 1f4:	d1 f7       	brne	.-12     	; 0x1ea <SD_Loop_SaveData>
	rcall	GPStoSDbuffer		// copy buffer_gps_ubx to buffer_sd
 1f6:	49 d0       	rcall	.+146    	; 0x28a <GPStoSDbuffer>
	dec		COUNTER				// IF there are 4 ubx strings then send buffer_sd to SD card
 1f8:	3a 95       	dec	r19
	brne	SD_Loop_SaveData	// IF no, look for other string
 1fa:	b9 f7       	brne	.-18     	; 0x1ea <SD_Loop_SaveData>

	ldi		YH,hi8(buffer_sd)
 1fc:	d1 e0       	ldi	r29, 0x01	; 1
	ldi		YL,lo8(buffer_sd)
 1fe:	c0 e0       	ldi	r28, 0x00	; 0
	rcall	SD_escribirBloque	//Send buffer_sd to SD card
 200:	36 d1       	rcall	.+620    	; 0x46e <SD_escribirBloque>
	cpi		ANS,0				//if ANS == 0 write succed
 202:	80 30       	cpi	r24, 0x00	; 0
	brne	SD_WRerror			// else, error, quit programm
 204:	41 f4       	brne	.+16     	; 0x216 <SD_WRerror>
	inc		LOWSECTOR			// increment low sector
 206:	63 95       	inc	r22
	lds		TEMP,SREG
 208:	00 91 3f 00 	lds	r16, 0x003F	; 0x80003f <__TEXT_REGION_LENGTH__+0x7e003f>
	sbic	TEMP,0				//if carry flag set, increment high sector
 20c:	80 99       	sbic	0x10, 0	; 16
	inc		HIGHSECTOR			
 20e:	73 95       	inc	r23
	cpi		HIGHSECTOR,255		//Check for max memmory for SD (65535 sectors)
 210:	7f 3f       	cpi	r23, 0xFF	; 255
	breq	SD_outOfMemmory		// if out of memmory, print in LCD and quit program
 212:	39 f0       	breq	.+14     	; 0x222 <SD_outOfMemmory>
	rjmp	loop				// if not, do it all again
 214:	e7 cf       	rjmp	.-50     	; 0x1e4 <loop>

00000216 <SD_WRerror>:

SD_WRerror:
	rcall	LCD_Borrar
 216:	90 df       	rcall	.-224    	; 0x138 <LCD_Borrar>
	ldi		ZH,hi8(sd_wrerror)
 218:	f1 e0       	ldi	r31, 0x01	; 1
	ldi		ZL,lo8(sd_wrerror)
 21a:	e4 eb       	ldi	r30, 0xB4	; 180
	rcall	LCD_ImprimirString
 21c:	7b df       	rcall	.-266    	; 0x114 <LCD_ImprimirString>
	rcall	DELAY1S
 21e:	38 df       	rcall	.-400    	; 0x90 <DELAY1S>
	rjmp	SD_WRerror
 220:	fa cf       	rjmp	.-12     	; 0x216 <SD_WRerror>

00000222 <SD_outOfMemmory>:

SD_outOfMemmory:
	rcall	LCD_Borrar
 222:	8a df       	rcall	.-236    	; 0x138 <LCD_Borrar>
	ldi		ZH,hi8(sd_outofmem)
 224:	f1 e0       	ldi	r31, 0x01	; 1
	ldi		ZL,lo8(sd_outofmem)
 226:	e3 ec       	ldi	r30, 0xC3	; 195
	rcall	LCD_ImprimirString
 228:	75 df       	rcall	.-278    	; 0x114 <LCD_ImprimirString>
	rcall	DELAY1S
 22a:	32 df       	rcall	.-412    	; 0x90 <DELAY1S>
	rjmp	SD_outOfMemmory
 22c:	fa cf       	rjmp	.-12     	; 0x222 <SD_outOfMemmory>

0000022e <initializations>:
// Input: none
// Output: none
// ******************************************************************
initializations:
	//LCD initialization
	rcall	LCD_init
 22e:	50 df       	rcall	.-352    	; 0xd0 <LCD_init>
	rcall	DELAY10MS
 230:	3d df       	rcall	.-390    	; 0xac <DELAY10MS>
	//SPI initialization
	rcall	SPI_init
 232:	ec d0       	rcall	.+472    	; 0x40c <SPI_init>
	rcall	DELAY10MS
 234:	3b df       	rcall	.-394    	; 0xac <DELAY10MS>
	//SD initialization
	rcall	SD_init
 236:	f5 d0       	rcall	.+490    	; 0x422 <SD_init>
	rcall	DELAY10MS
 238:	39 df       	rcall	.-398    	; 0xac <DELAY10MS>
	//USART initialization
	rcall	USART_init
 23a:	67 d1       	rcall	.+718    	; 0x50a <USART_init>
	rcall	DELAY10MS
 23c:	37 df       	rcall	.-402    	; 0xac <DELAY10MS>
	//startSector initialization
	ldi		LOWSECTOR,0x00
 23e:	60 e0       	ldi	r22, 0x00	; 0
	ldi		HIGHSECTOR,0x00
 240:	70 e0       	ldi	r23, 0x00	; 0
	rcall   DELAY100MS
 242:	2d df       	rcall	.-422    	; 0x9e <DELAY100MS>
	rcall	LCD_Borrar
 244:	79 df       	rcall	.-270    	; 0x138 <LCD_Borrar>
	ret
 246:	08 95       	ret

00000248 <bufferSDErase>:
// bufferSDErase: erase content of buffer_sd
// Input: none
// Output: none
// ******************************************************************
bufferSDErase:
	push	ZL
 248:	ef 93       	push	r30
	push	ZH
 24a:	ff 93       	push	r31
	push	TEMP
 24c:	0f 93       	push	r16
	push	TEMP2
 24e:	1f 93       	push	r17

	ldi		ZH,hi8(buffer_sd)
 250:	f1 e0       	ldi	r31, 0x01	; 1
	ldi		ZL,lo8(buffer_sd)
 252:	e0 e0       	ldi	r30, 0x00	; 0
	ldi		TEMP,0
 254:	00 e0       	ldi	r16, 0x00	; 0
	ldi		TEMP2,0
 256:	10 e0       	ldi	r17, 0x00	; 0

00000258 <eraseSDLoop>:
eraseSDLoop:
	st		Z+,0x00
 258:	01 92       	st	Z+, r0
	inc		TEMP
 25a:	03 95       	inc	r16
	brne	eraseSDLoop
 25c:	e9 f7       	brne	.-6      	; 0x258 <eraseSDLoop>
	inc		TEMP2
 25e:	13 95       	inc	r17
	cpi		TEMP2,2
 260:	12 30       	cpi	r17, 0x02	; 2
	brne	eraseSDLoop
 262:	d1 f7       	brne	.-12     	; 0x258 <eraseSDLoop>

	pop		TEMP2
 264:	1f 91       	pop	r17
	pop		TEMP
 266:	0f 91       	pop	r16
	pop		ZL
 268:	ef 91       	pop	r30
	pop		ZH
 26a:	ff 91       	pop	r31
	ret
 26c:	08 95       	ret

0000026e <bufferGPSErase>:
// bufferGPSErase: erase content of buffer_gps_ubx
// Input: none
// Output: none
// ******************************************************************
bufferGPSErase:
	push	ZL
 26e:	ef 93       	push	r30
	push	ZH
 270:	ff 93       	push	r31
	push	TEMP
 272:	0f 93       	push	r16

	ldi		ZH,hi8(buffer_gps_ubx)
 274:	f3 e0       	ldi	r31, 0x03	; 3
	ldi		ZL,lo8(buffer_gps_ubx)
 276:	e0 e0       	ldi	r30, 0x00	; 0
	ldi		TEMP,0
 278:	00 e0       	ldi	r16, 0x00	; 0

0000027a <eraseGPSLoop>:
eraseGPSLoop:
	st		Z+,0x00
 27a:	01 92       	st	Z+, r0
	inc		TEMP
 27c:	03 95       	inc	r16
	cpi		TEMP,126
 27e:	0e 37       	cpi	r16, 0x7E	; 126
	brne	eraseGPSLoop
 280:	e1 f7       	brne	.-8      	; 0x27a <eraseGPSLoop>

	pop		TEMP
 282:	0f 91       	pop	r16
	pop		ZL
 284:	ef 91       	pop	r30
	pop		ZH
 286:	ff 91       	pop	r31
	ret
 288:	08 95       	ret

0000028a <GPStoSDbuffer>:
// of Y in buffer_sd
// Input: Y - pointer to buffer_sd (last end of position)
// Output:Y - pointer to buffer_sd (new end of position)
// ******************************************************************
GPStoSDbuffer:
	push	ZL
 28a:	ef 93       	push	r30
	push	ZH
 28c:	ff 93       	push	r31
	push	TEMP
 28e:	0f 93       	push	r16
	push	DATA
 290:	4f 93       	push	r20

	ldi		ZH,hi8(buffer_gps_ubx)
 292:	f3 e0       	ldi	r31, 0x03	; 3
	ldi		ZL,lo8(buffer_gps_ubx)
 294:	e0 e0       	ldi	r30, 0x00	; 0

00000296 <GPStoSDLoop>:
GPStoSDLoop:
	ld		TEMP,Z+			//load char from buffer_gps_ubx
 296:	01 91       	ld	r16, Z+
	st		Y+,TEMP			//store in buffer_sd
 298:	09 93       	st	Y+, r16
	cpi		TEMP,10			//IF Line Feed, end of protocol
 29a:	0a 30       	cpi	r16, 0x0A	; 10
	brne	GPStoSDLoop
 29c:	e1 f7       	brne	.-8      	; 0x296 <GPStoSDLoop>
	ld		TEMP,Z			//load last char
 29e:	00 81       	ld	r16, Z
	st		Y+,TEMP			//store last char
 2a0:	09 93       	st	Y+, r16
	pop		DATA
 2a2:	4f 91       	pop	r20
	pop		TEMP
 2a4:	0f 91       	pop	r16
	pop		ZH
 2a6:	ff 91       	pop	r31
	pop		ZL
 2a8:	ef 91       	pop	r30
	ret
 2aa:	08 95       	ret

000002ac <LCD_printLine1>:
// LCD_printLine1: Prints relevant data to the LCD 1st line
// Input: buffer_gps_ubx,LOWSECTOR,HIGHSECTOR (all untouched)
// Output: none
// ******************************************************************
LCD_printLine1:
	push	ZL
 2ac:	ef 93       	push	r30
	push	ZH
 2ae:	ff 93       	push	r31
	push	TEMP
 2b0:	0f 93       	push	r16
	push	COUNTER
 2b2:	3f 93       	push	r19
//First column 16 chars
	rcall	LCD_Borrar
 2b4:	41 df       	rcall	.-382    	; 0x138 <LCD_Borrar>
//print sector		4 char + space
	mov		TEMP,HIGHSECTOR
 2b6:	07 2f       	mov	r16, r23
	swap	TEMP
 2b8:	02 95       	swap	r16
	rcall	HexToAscii
 2ba:	7a d0       	rcall	.+244    	; 0x3b0 <HexToAscii>
	rcall	LCD_EnviarChar
 2bc:	5b df       	rcall	.-330    	; 0x174 <LCD_EnviarChar>
	mov		TEMP,HIGHSECTOR
 2be:	07 2f       	mov	r16, r23
	rcall	HexToAscii
 2c0:	77 d0       	rcall	.+238    	; 0x3b0 <HexToAscii>
	rcall	LCD_EnviarChar
 2c2:	58 df       	rcall	.-336    	; 0x174 <LCD_EnviarChar>
	mov		TEMP,LOWSECTOR
 2c4:	06 2f       	mov	r16, r22
	swap	TEMP
 2c6:	02 95       	swap	r16
	rcall	HexToAscii
 2c8:	73 d0       	rcall	.+230    	; 0x3b0 <HexToAscii>
	rcall	LCD_EnviarChar
 2ca:	54 df       	rcall	.-344    	; 0x174 <LCD_EnviarChar>
	mov		TEMP,LOWSECTOR
 2cc:	06 2f       	mov	r16, r22
	rcall	HexToAscii
 2ce:	70 d0       	rcall	.+224    	; 0x3b0 <HexToAscii>
	rcall	LCD_EnviarChar
 2d0:	51 df       	rcall	.-350    	; 0x174 <LCD_EnviarChar>
	ldi		TEMP,' '
 2d2:	00 e2       	ldi	r16, 0x20	; 32
	rcall	LCD_EnviarChar
 2d4:	4f df       	rcall	.-354    	; 0x174 <LCD_EnviarChar>
//check if it is $PUBX
	ldi		ZL,lo8(buffer_gps_ubx)
 2d6:	e0 e0       	ldi	r30, 0x00	; 0
	ldi		ZH,hi8(buffer_gps_ubx)
 2d8:	f3 e0       	ldi	r31, 0x03	; 3
	ld		TEMP,Z+
 2da:	01 91       	ld	r16, Z+
	ld		TEMP,Z
 2dc:	00 81       	ld	r16, Z
	cpi		TEMP,'P'
 2de:	00 35       	cpi	r16, 0x50	; 80
	brne	printLine1End
 2e0:	41 f5       	brne	.+80     	; 0x332 <printLine1End>
//print fix			2 char + space
	ldi		ZL,lo8(buffer_gps_ubx)
 2e2:	e0 e0       	ldi	r30, 0x00	; 0
	ldi		ZH,hi8(buffer_gps_ubx)
 2e4:	f3 e0       	ldi	r31, 0x03	; 3
	ldi		COUNTER,8					// after the 8 comma, Fix is placed
 2e6:	38 e0       	ldi	r19, 0x08	; 8

000002e8 <fixLoop>:
fixLoop:
	ld		TEMP,Z+
 2e8:	01 91       	ld	r16, Z+
	cpi		TEMP,','
 2ea:	0c 32       	cpi	r16, 0x2C	; 44
	brne	fixLoop
 2ec:	e9 f7       	brne	.-6      	; 0x2e8 <fixLoop>
	dec		COUNTER
 2ee:	3a 95       	dec	r19
	brne	fixLoop
 2f0:	d9 f7       	brne	.-10     	; 0x2e8 <fixLoop>
	ld		TEMP,Z+
 2f2:	01 91       	ld	r16, Z+
	rcall	LCD_EnviarChar
 2f4:	3f df       	rcall	.-386    	; 0x174 <LCD_EnviarChar>
	ld		TEMP,Z
 2f6:	00 81       	ld	r16, Z
	rcall	LCD_EnviarChar
 2f8:	3d df       	rcall	.-390    	; 0x174 <LCD_EnviarChar>
	ldi		TEMP,' '
 2fa:	00 e2       	ldi	r16, 0x20	; 32
	rcall	LCD_EnviarChar
 2fc:	3b df       	rcall	.-394    	; 0x174 <LCD_EnviarChar>
//print time		8 char
	ldi		ZL,lo8(buffer_gps_ubx)
 2fe:	e0 e0       	ldi	r30, 0x00	; 0
	ldi		ZH,hi8(buffer_gps_ubx)
 300:	f3 e0       	ldi	r31, 0x03	; 3
	ldi		COUNTER,2					// after the 2 comma, Time is placed
 302:	32 e0       	ldi	r19, 0x02	; 2

00000304 <timeLoop>:
timeLoop:
	ld		TEMP,Z+
 304:	01 91       	ld	r16, Z+
	cpi		TEMP,','
 306:	0c 32       	cpi	r16, 0x2C	; 44
	brne	timeLoop
 308:	e9 f7       	brne	.-6      	; 0x304 <timeLoop>
	dec		COUNTER
 30a:	3a 95       	dec	r19
	brne	timeLoop
 30c:	d9 f7       	brne	.-10     	; 0x304 <timeLoop>
	ld		TEMP,Z+
 30e:	01 91       	ld	r16, Z+
	rcall	LCD_EnviarChar
 310:	31 df       	rcall	.-414    	; 0x174 <LCD_EnviarChar>
	ld		TEMP,Z+
 312:	01 91       	ld	r16, Z+
	rcall	LCD_EnviarChar
 314:	2f df       	rcall	.-418    	; 0x174 <LCD_EnviarChar>
	ldi		TEMP,':'
 316:	0a e3       	ldi	r16, 0x3A	; 58
	rcall	LCD_EnviarChar
 318:	2d df       	rcall	.-422    	; 0x174 <LCD_EnviarChar>
	ld		TEMP,Z+
 31a:	01 91       	ld	r16, Z+
	rcall	LCD_EnviarChar
 31c:	2b df       	rcall	.-426    	; 0x174 <LCD_EnviarChar>
	ld		TEMP,Z+
 31e:	01 91       	ld	r16, Z+
	rcall	LCD_EnviarChar
 320:	29 df       	rcall	.-430    	; 0x174 <LCD_EnviarChar>
	ldi		TEMP,':'
 322:	0a e3       	ldi	r16, 0x3A	; 58
	rcall	LCD_EnviarChar
 324:	27 df       	rcall	.-434    	; 0x174 <LCD_EnviarChar>
	ld		TEMP,Z+
 326:	01 91       	ld	r16, Z+
	rcall	LCD_EnviarChar
 328:	25 df       	rcall	.-438    	; 0x174 <LCD_EnviarChar>
	ld		TEMP,Z+
 32a:	01 91       	ld	r16, Z+
	rcall	LCD_EnviarChar
 32c:	23 df       	rcall	.-442    	; 0x174 <LCD_EnviarChar>
	ldi		TEMP,' '
 32e:	00 e2       	ldi	r16, 0x20	; 32
	rcall	LCD_EnviarChar
 330:	21 df       	rcall	.-446    	; 0x174 <LCD_EnviarChar>

00000332 <printLine1End>:
printLine1End:
	pop		COUNTER
 332:	3f 91       	pop	r19
	pop		TEMP
 334:	0f 91       	pop	r16
	pop		ZH
 336:	ff 91       	pop	r31
	pop		ZL
 338:	ef 91       	pop	r30
	ret
 33a:	08 95       	ret

0000033c <LCD_printLine2>:
// LCD_printLine2: Prints relevant data to the LCD 1st line
// Input: buffer_gps_ubx,LOWSECTOR,HIGHSECTOR (all untouched)
// Output: none
// ******************************************************************
LCD_printLine2:
	push	ZL
 33c:	ef 93       	push	r30
	push	ZH
 33e:	ff 93       	push	r31
	push	TEMP
 340:	0f 93       	push	r16
	push	COUNTER
 342:	3f 93       	push	r19
//Second Column 16 chars
	ldi		TEMP,0xC0        // Move cursor to second line 0b11000000
 344:	00 ec       	ldi	r16, 0xC0	; 192
	rcall	LCD_EnviarCmd
 346:	ff de       	rcall	.-514    	; 0x146 <LCD_EnviarCmd>

//print speed km/h
	ldi		TEMP,'S'
 348:	03 e5       	ldi	r16, 0x53	; 83
	rcall	LCD_EnviarChar
 34a:	14 df       	rcall	.-472    	; 0x174 <LCD_EnviarChar>
	ldi		TEMP,'O'
 34c:	0f e4       	ldi	r16, 0x4F	; 79
	rcall	LCD_EnviarChar
 34e:	12 df       	rcall	.-476    	; 0x174 <LCD_EnviarChar>
	ldi		TEMP,'G'
 350:	07 e4       	ldi	r16, 0x47	; 71
	rcall	LCD_EnviarChar
 352:	10 df       	rcall	.-480    	; 0x174 <LCD_EnviarChar>
	ldi		TEMP,' '
 354:	00 e2       	ldi	r16, 0x20	; 32
	rcall	LCD_EnviarChar
 356:	0e df       	rcall	.-484    	; 0x174 <LCD_EnviarChar>
	ldi		ZL,lo8(buffer_gps_ubx)
 358:	e0 e0       	ldi	r30, 0x00	; 0
	ldi		ZH,hi8(buffer_gps_ubx)
 35a:	f3 e0       	ldi	r31, 0x03	; 3
	ldi		COUNTER,11					// after the 3 comma, Latitude is placed
 35c:	3b e0       	ldi	r19, 0x0B	; 11

0000035e <speedLoop>:
speedLoop:
	ld		TEMP,Z+
 35e:	01 91       	ld	r16, Z+
	cpi		TEMP,','
 360:	0c 32       	cpi	r16, 0x2C	; 44
	brne	speedLoop
 362:	e9 f7       	brne	.-6      	; 0x35e <speedLoop>
	dec		COUNTER
 364:	3a 95       	dec	r19
	brne	speedLoop
 366:	d9 f7       	brne	.-10     	; 0x35e <speedLoop>
	ld		TEMP,Z+
 368:	01 91       	ld	r16, Z+

0000036a <speedLoop2>:
speedLoop2:
	rcall	LCD_EnviarChar
 36a:	04 df       	rcall	.-504    	; 0x174 <LCD_EnviarChar>
	ld		TEMP,Z+
 36c:	01 91       	ld	r16, Z+
	cpi		TEMP,'.'
 36e:	0e 32       	cpi	r16, 0x2E	; 46
	brne	speedLoop2
 370:	e1 f7       	brne	.-8      	; 0x36a <speedLoop2>
	rcall	LCD_EnviarChar
 372:	00 df       	rcall	.-512    	; 0x174 <LCD_EnviarChar>
	// one digit for speed only
	ld		TEMP,Z+
 374:	01 91       	ld	r16, Z+
	rcall	LCD_EnviarChar
 376:	fe de       	rcall	.-516    	; 0x174 <LCD_EnviarChar>
	ldi		TEMP,' '
 378:	00 e2       	ldi	r16, 0x20	; 32
	rcall	LCD_EnviarChar
 37a:	fc de       	rcall	.-520    	; 0x174 <LCD_EnviarChar>
//print heading
	ldi		TEMP,'C'
 37c:	03 e4       	ldi	r16, 0x43	; 67
	rcall	LCD_EnviarChar
 37e:	fa de       	rcall	.-524    	; 0x174 <LCD_EnviarChar>
	ldi		TEMP,'O'
 380:	0f e4       	ldi	r16, 0x4F	; 79
	rcall	LCD_EnviarChar
 382:	f8 de       	rcall	.-528    	; 0x174 <LCD_EnviarChar>
	ldi		TEMP,'G'
 384:	07 e4       	ldi	r16, 0x47	; 71
	rcall	LCD_EnviarChar
 386:	f6 de       	rcall	.-532    	; 0x174 <LCD_EnviarChar>
	ldi		TEMP,' '
 388:	00 e2       	ldi	r16, 0x20	; 32
	rcall	LCD_EnviarChar
 38a:	f4 de       	rcall	.-536    	; 0x174 <LCD_EnviarChar>
	ldi		ZL,lo8(buffer_gps_ubx)
 38c:	e0 e0       	ldi	r30, 0x00	; 0
	ldi		ZH,hi8(buffer_gps_ubx)
 38e:	f3 e0       	ldi	r31, 0x03	; 3
	ldi		COUNTER,12  				// after the 3 comma, Latitude is placed
 390:	3c e0       	ldi	r19, 0x0C	; 12

00000392 <headingLoop>:
headingLoop:
	ld		TEMP,Z+
 392:	01 91       	ld	r16, Z+
	cpi		TEMP,','
 394:	0c 32       	cpi	r16, 0x2C	; 44
	brne	headingLoop
 396:	e9 f7       	brne	.-6      	; 0x392 <headingLoop>
	dec		COUNTER
 398:	3a 95       	dec	r19
	brne	headingLoop
 39a:	d9 f7       	brne	.-10     	; 0x392 <headingLoop>
	ld		TEMP,Z+
 39c:	01 91       	ld	r16, Z+

0000039e <headingLoop2>:
headingLoop2:
	rcall	LCD_EnviarChar
 39e:	ea de       	rcall	.-556    	; 0x174 <LCD_EnviarChar>
	ld		TEMP,Z+
 3a0:	01 91       	ld	r16, Z+
	cpi		TEMP,'.'
 3a2:	0e 32       	cpi	r16, 0x2E	; 46
	brne	headingLoop2
 3a4:	e1 f7       	brne	.-8      	; 0x39e <headingLoop2>

000003a6 <printLine2End>:
printLine2End:
	pop		COUNTER
 3a6:	3f 91       	pop	r19
	pop		TEMP
 3a8:	0f 91       	pop	r16
	pop		ZH
 3aa:	ff 91       	pop	r31
	pop		ZL
 3ac:	ef 91       	pop	r30
	ret
 3ae:	08 95       	ret

000003b0 <HexToAscii>:
// HexToAscii: Change the content of first nibble in TEMP from HEX to ASCII
// Input: TEMP(first nibble) - HEX nibble
// Output:TEMP - ASCII value
// ******************************************************************
HexToAscii:
	push	TEMP2
 3b0:	1f 93       	push	r17

	andi	TEMP,0x0F
 3b2:	0f 70       	andi	r16, 0x0F	; 15
	cpi		TEMP,0x0A
 3b4:	0a 30       	cpi	r16, 0x0A	; 10
	brge	AtoF
 3b6:	24 f4       	brge	.+8      	; 0x3c0 <AtoF>
	ldi		TEMP2,0x30	// IF TEMP is 0 to 9
 3b8:	10 e3       	ldi	r17, 0x30	; 48
	add	TEMP,TEMP2		// 0x30H is 0 
 3ba:	01 0f       	add	r16, r17

	pop		TEMP2
 3bc:	1f 91       	pop	r17
	ret
 3be:	08 95       	ret

000003c0 <AtoF>:

AtoF:						// IF TEMP is A to F
	ldi		TEMP2,0x37
 3c0:	17 e3       	ldi	r17, 0x37	; 55
	add		TEMP,TEMP2		// 0x41H is A and 37h+10d = 41h
 3c2:	01 0f       	add	r16, r17


	pop		TEMP2
 3c4:	1f 91       	pop	r17
 3c6:	08 95       	ret

000003c8 <lcdinit>:
 3c8:	4c 43       	sbci	r20, 0x3C	; 60
 3ca:	44 20       	and	r4, r4
 3cc:	49 6e       	ori	r20, 0xE9	; 233
 3ce:	69 63       	ori	r22, 0x39	; 57
 3d0:	69 61       	ori	r22, 0x19	; 25
 3d2:	6c 69       	ori	r22, 0x9C	; 156
 3d4:	7a 61       	ori	r23, 0x1A	; 26
 3d6:	64 6f       	ori	r22, 0xF4	; 244
	...

000003d9 <sdinit>:
 3d9:	53 44       	sbci	r21, 0x43	; 67
 3db:	20 49       	sbci	r18, 0x90	; 144
 3dd:	6e 69       	ori	r22, 0x9E	; 158
 3df:	63 69       	ori	r22, 0x93	; 147
 3e1:	61 6c       	ori	r22, 0xC1	; 193
 3e3:	69 7a       	andi	r22, 0xA9	; 169
 3e5:	61 64       	ori	r22, 0x41	; 65
 3e7:	6f 20       	and	r6, r15
	...

000003ea <sderror1>:
 3ea:	53 44       	sbci	r21, 0x43	; 67
 3ec:	20 6e       	ori	r18, 0xE0	; 224
 3ee:	6f 20       	and	r6, r15
 3f0:	64 65       	ori	r22, 0x54	; 84
 3f2:	74 65       	ori	r23, 0x54	; 84
 3f4:	63 74       	andi	r22, 0x43	; 67
 3f6:	61 64       	ori	r22, 0x41	; 65
 3f8:	61 20       	and	r6, r1
	...

000003fb <sderror2>:
 3fb:	46 41       	sbci	r20, 0x16	; 22
 3fd:	4c 4c       	sbci	r20, 0xCC	; 204
 3ff:	41 20       	and	r4, r1
 401:	69 6e       	ori	r22, 0xE9	; 233
 403:	69 74       	andi	r22, 0x49	; 73
 405:	20 53       	subi	r18, 0x30	; 48
 407:	44 20       	and	r4, r4
 409:	20 20       	and	r2, r0
	...

0000040c <SPI_init>:
//SPI_init: Inicializa el puerto de la tarjeta SD y y la configuracion del SPI
//parametros de entrada: Ninguno
//parametros de salida: Ninguno
//******************************************************************
SPI_init:
	push	TEMP
 40c:	0f 93       	push	r16

	ldi		TEMP,0xFB
 40e:	0b ef       	ldi	r16, 0xFB	; 251
	out		SD_PORT,TEMP	// Chip Select (PB2) OFF, resto ON
 410:	05 b9       	out	0x05, r16	; 5
	ldi		TEMP,0XEF
 412:	0f ee       	ldi	r16, 0xEF	; 239
	out		SD_DDR,TEMP		//MISO (PB4) input, resto output
 414:	04 b9       	out	0x04, r16	; 4
	ldi		TEMP,0x52		
 416:	02 e5       	ldi	r16, 0x52	; 82
	out		SPCR,TEMP		//Configuracion del SPI: Master mode, MSB primero, SCK phase low, SCK idle low
 418:	0c bd       	out	0x2c, r16	; 44
	ldi		TEMP,0x00
 41a:	00 e0       	ldi	r16, 0x00	; 0
	out		SPSR,TEMP		//Status Register en 0
 41c:	0d bd       	out	0x2d, r16	; 45

	pop		TEMP
 41e:	0f 91       	pop	r16
	ret
 420:	08 95       	ret

00000422 <SD_init>:
//SD_init: Inicializa la tarjeta SD y termina el programa si hay algun error
//parametros de entrada: Ninguno
//parametros de salida: Ninguno
//******************************************************************
SD_init:
	clr		24					//compatibilidad con subrutina en C
 422:	88 27       	eor	r24, r24
	clr		25				
 424:	99 27       	eor	r25, r25
	rcall	SD_initialization
 426:	3a d1       	rcall	.+628    	; 0x69c <SD_initialization>
	cpi		RESPUESTA,0
 428:	80 30       	cpi	r24, 0x00	; 0
	brne	SD_error1
 42a:	29 f4       	brne	.+10     	; 0x436 <SD_error1>
	ldi		ZH,hi8(sdinit)
 42c:	f3 e0       	ldi	r31, 0x03	; 3
	ldi		ZL,lo8(sdinit)
 42e:	e9 ed       	ldi	r30, 0xD9	; 217
	rcall	LCD_ImprimirString
 430:	71 de       	rcall	.-798    	; 0x114 <LCD_ImprimirString>
	rjmp	initEnd
 432:	0c c0       	rjmp	.+24     	; 0x44c <initEnd>
	rcall   LCD_Borrar
 434:	81 de       	rcall	.-766    	; 0x138 <LCD_Borrar>

00000436 <SD_error1>:
SD_error1:
	cpi		RESPUESTA,1
 436:	81 30       	cpi	r24, 0x01	; 1
	brne	SD_error2
 438:	21 f4       	brne	.+8      	; 0x442 <SD_error2>
	ldi		ZH,hi8(sderror1)
 43a:	f3 e0       	ldi	r31, 0x03	; 3
	ldi		ZL,lo8(sderror1)
 43c:	ea ee       	ldi	r30, 0xEA	; 234
	rcall	LCD_ImprimirString
 43e:	6a de       	rcall	.-812    	; 0x114 <LCD_ImprimirString>
	rjmp	error_sd_loop
 440:	04 c0       	rjmp	.+8      	; 0x44a <error_sd_loop>

00000442 <SD_error2>:
SD_error2:
	ldi		ZH,hi8(sderror2)
 442:	f3 e0       	ldi	r31, 0x03	; 3
	ldi		ZL,lo8(sderror2)
 444:	eb ef       	ldi	r30, 0xFB	; 251
	rcall	LCD_ImprimirString
 446:	66 de       	rcall	.-820    	; 0x114 <LCD_ImprimirString>
	rjmp    error_sd_loop
 448:	00 c0       	rjmp	.+0      	; 0x44a <error_sd_loop>

0000044a <error_sd_loop>:
error_sd_loop:
    rjmp error_sd_loop
 44a:	ff cf       	rjmp	.-2      	; 0x44a <error_sd_loop>

0000044c <initEnd>:
	//rjmp	SD_error2
initEnd:
	ret
 44c:	08 95       	ret

0000044e <SD_erase>:
//SD_erase: Escribe en el bloque elegido el contenido de un espacio de memoria
//parametros de entrada: Y: Y=buffer, 22=LOWSECTOR, 23=HIGHSECTOR
//parametros de salida: 24=Respuesta. 0 si no hay error
//******************************************************************
SD_erase:
	push	COUNTER
 44e:	3f 93       	push	r19
	push	TEMP
 450:	0f 93       	push	r16
	push	YL
 452:	cf 93       	push	r28
	push	YH
 454:	df 93       	push	r29

	ldi		TEMP,0
 456:	00 e0       	ldi	r16, 0x00	; 0
	ldi		COUNTER,2		//to make 255 times the loop
 458:	32 e0       	ldi	r19, 0x02	; 2

0000045a <eraseLoop>:
eraseLoop:
	st		Y+,TEMP
 45a:	09 93       	st	Y+, r16
	st		Y+,TEMP
 45c:	09 93       	st	Y+, r16
	inc		COUNTER
 45e:	33 95       	inc	r19
	brne	eraseLoop
 460:	e1 f7       	brne	.-8      	; 0x45a <eraseLoop>

	rcall	SD_writeSingleBlock
 462:	af d1       	rcall	.+862    	; 0x7c2 <SD_writeSingleBlock>

	pop		YH
 464:	df 91       	pop	r29
	pop		YL
 466:	cf 91       	pop	r28
	pop		TEMP
 468:	0f 91       	pop	r16
	pop		COUNTER
 46a:	3f 91       	pop	r19
	ret
 46c:	08 95       	ret

0000046e <SD_escribirBloque>:
//SD_escribirBloque: Escribe en el bloque elegido el contenido de un espacio de memoria
//parametros de entrada: Y: Y=buffer, 22=LOWSECTOR, 23=HIGHSECTOR
//parametros de salida: 24=Respuesta. 0 si no hay error
//******************************************************************
SD_escribirBloque:
	push	ZL
 46e:	ef 93       	push	r30
	push	ZH
 470:	ff 93       	push	r31
	push	YL
 472:	cf 93       	push	r28
	push	YH
 474:	df 93       	push	r29
	push	18
 476:	2f 93       	push	r18
	push	19
 478:	3f 93       	push	r19
	push	20
 47a:	4f 93       	push	r20
	push	21
 47c:	5f 93       	push	r21
	push	22
 47e:	6f 93       	push	r22
	push	23
 480:	7f 93       	push	r23
	push	25
 482:	9f 93       	push	r25
	push	26
 484:	af 93       	push	r26
	push	27
 486:	bf 93       	push	r27
	push	1
 488:	1f 92       	push	r1
	//r1 para C siempre tiene que estar en 0
	ldi		TEMP,0x00
 48a:	00 e0       	ldi	r16, 0x00	; 0
	mov		1,TEMP
 48c:	10 2e       	mov	r1, r16
	//startblock es unsigned long (4 bytes) pero no vamos a usar mas de 650000 sectores asi que se dejan en 0 los ultimos 2
	ldi		25,0x00
 48e:	90 e0       	ldi	r25, 0x00	; 0
	ldi		24,0x00
 490:	80 e0       	ldi	r24, 0x00	; 0
	//22 y 23 son bloque low y high
	//char* es puntero a buffer (2 bytes)
	mov		21,YH
 492:	5d 2f       	mov	r21, r29
	mov		20,YL
 494:	4c 2f       	mov	r20, r28
	//llamo a la funcion
	rcall	SD_writeSingleBlock
 496:	95 d1       	rcall	.+810    	; 0x7c2 <SD_writeSingleBlock>
	//return en r24 = RESPUESTA
	pop		1
 498:	1f 90       	pop	r1
	pop		27
 49a:	bf 91       	pop	r27
	pop		26
 49c:	af 91       	pop	r26
	pop		25
 49e:	9f 91       	pop	r25
	pop		23
 4a0:	7f 91       	pop	r23
	pop		22
 4a2:	6f 91       	pop	r22
	pop		21
 4a4:	5f 91       	pop	r21
	pop		20
 4a6:	4f 91       	pop	r20
	pop		19
 4a8:	3f 91       	pop	r19
	pop		18
 4aa:	2f 91       	pop	r18
	pop		YH
 4ac:	df 91       	pop	r29
	pop		YL
 4ae:	cf 91       	pop	r28
	pop		ZH
 4b0:	ff 91       	pop	r31
	pop		ZL
 4b2:	ef 91       	pop	r30
	ret
 4b4:	08 95       	ret

000004b6 <SD_leerBloque>:
//SD_escribirBloque: Lee el bloque elegido y lo almacena en un buffer
//parametros de entrada: Y: Y=buffer, 22=LOWSECTOR, 23=HIGHSECTOR
//parametros de salida: 24=Respuesta. 0 si no hay error
//******************************************************************
SD_leerBloque:
	push	ZL
 4b6:	ef 93       	push	r30
	push	ZH
 4b8:	ff 93       	push	r31
	push	18
 4ba:	2f 93       	push	r18
	push	19
 4bc:	3f 93       	push	r19
	push	20
 4be:	4f 93       	push	r20
	push	21
 4c0:	5f 93       	push	r21
	push	22
 4c2:	6f 93       	push	r22
	push	23
 4c4:	7f 93       	push	r23
	push	25
 4c6:	9f 93       	push	r25
	push	26
 4c8:	af 93       	push	r26
	push	27
 4ca:	bf 93       	push	r27
	push	1
 4cc:	1f 92       	push	r1
	//r1 para C siempre tiene que estar en 0
	ldi		TEMP,0x00
 4ce:	00 e0       	ldi	r16, 0x00	; 0
	mov		1,TEMP
 4d0:	10 2e       	mov	r1, r16
	//startblock es unsigned long (4 bytes) pero no vamos a usar mas de 650000 sectores asi que se dejan en 0 los ultimos 2
	ldi		25,0x00
 4d2:	90 e0       	ldi	r25, 0x00	; 0
	ldi		24,0x00
 4d4:	80 e0       	ldi	r24, 0x00	; 0
	//22 y 23 son bloque 1 y 2
	//char* es puntero a buffer (2 bytes)
	ldi		21,ZH
 4d6:	5f e1       	ldi	r21, 0x1F	; 31
	ldi		20,ZL
 4d8:	4e e1       	ldi	r20, 0x1E	; 30
	//llamo a la funcion
	rcall	SD_readSingleBlock
 4da:	bd d1       	rcall	.+890    	; 0x856 <SD_readSingleBlock>
	//return en r24 = RESPUESTA
	pop		1
 4dc:	1f 90       	pop	r1
	pop		27
 4de:	bf 91       	pop	r27
	pop		26
 4e0:	af 91       	pop	r26
	pop		25
 4e2:	9f 91       	pop	r25
	pop		23
 4e4:	7f 91       	pop	r23
	pop		22
 4e6:	6f 91       	pop	r22
	pop		21
 4e8:	5f 91       	pop	r21
	pop		20
 4ea:	4f 91       	pop	r20
	pop		19
 4ec:	3f 91       	pop	r19
	pop		18
 4ee:	2f 91       	pop	r18
	pop		ZH
 4f0:	ff 91       	pop	r31
	pop		ZL
 4f2:	ef 91       	pop	r30
 4f4:	08 95       	ret

000004f6 <gps_no_fix>:
 4f6:	4e 6f       	ori	r20, 0xFE	; 254
 4f8:	20 66       	ori	r18, 0x60	; 96
 4fa:	69 78       	andi	r22, 0x89	; 137
	...

000004fd <gps_fix_adquired>:
 4fd:	46 69       	ori	r20, 0x96	; 150
 4ff:	78 20       	and	r7, r8
 501:	41 64       	ori	r20, 0x41	; 65
 503:	71 75       	andi	r23, 0x51	; 81
 505:	69 72       	andi	r22, 0x29	; 41
 507:	65 64       	ori	r22, 0x45	; 69
	...

0000050a <USART_init>:
// USART_init: initialize USART
// Input: Nothing
// Output:Nothing
// ******************************************************************
USART_init:
	push	TEMP
 50a:	0f 93       	push	r16
	cbi		SERIAL_DDR,RX_PIN	//RX_PIN is an Input
 50c:	50 98       	cbi	0x0a, 0	; 10
	cbi		SERIAL_PORT,RX_PIN	//no PULLUP
 50e:	58 98       	cbi	0x0b, 0	; 11
	sbi		SERIAL_DDR,TX_PIN	//TX_PIN is an Output
 510:	51 9a       	sbi	0x0a, 1	; 10

	// USART Parameters:
	// 8 data bits, 1 stop bit, no parity
	// USART Baud Rate: 9600
	LDI		TEMP, lo8(UBRR)
 512:	07 e6       	ldi	r16, 0x67	; 103
	STS		UBRR0L,TEMP
 514:	00 93 c4 00 	sts	0x00C4, r16	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
	LDI		TEMP, hi8(UBRR)
 518:	00 e0       	ldi	r16, 0x00	; 0
	STS		UBRR0H,TEMP
 51a:	00 93 c5 00 	sts	0x00C5, r16	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>

	; Asynchronic mode (UMSEL01=0 y UMSEL00=0) No parity (UPM01=0 y UPM00=0), 1 stop bit (USBS0=0), 8 data bits (UCSZ01=1 y UCSZ00=1)
	; UCSR0C = |UMSEL01|UMSEL00|UPM01|UPM00|USBS0|UCSZ01|UCSZ00|UCPOL0|
	LDI		TEMP,(1<<UCSZ01)|(1<<UCSZ00)
 51e:	06 e0       	ldi	r16, 0x06	; 6
	STS		UCSR0C,TEMP
 520:	00 93 c2 00 	sts	0x00C2, r16	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>

	// RX enable (RXEN0), TX enable (TXEN0), UCSZ02=0 8 data bites
	// UCSR0B = |RXCIE0|TXCIE0|UDRIE0|RXEN0|TXEN0|UCSZ02|RXB80|TXB80|
	LDI		TEMP, (1<<RXEN0)|(1<<TXEN0)		//To activate interruption RXCIE0|(1<<RXCIE0)
 524:	08 e1       	ldi	r16, 0x18	; 24
	STS		UCSR0B, TEMP
 526:	00 93 c1 00 	sts	0x00C1, r16	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	//cli
	//sei
	pop		TEMP
 52a:	0f 91       	pop	r16
	ret
 52c:	08 95       	ret

0000052e <GPS_getString>:
// GPS_getString: get string from GPS using UART (UBX protocol)
// Input: buffer_gps_ubx empty
// Output: buffer_gps_ubx with string
// ******************************************************************
GPS_getString:
	push	TEMP
 52e:	0f 93       	push	r16
	push	DATA
 530:	4f 93       	push	r20
	push	ZL
 532:	ef 93       	push	r30
	push	ZH
 534:	ff 93       	push	r31

	ldi		ZH,hi8(buffer_gps_ubx)
 536:	f3 e0       	ldi	r31, 0x03	; 3
	ldi		ZL,lo8(buffer_gps_ubx)
 538:	e0 e0       	ldi	r30, 0x00	; 0

0000053a <getStringLoop>:
getStringLoop:
	rcall	Serial_RX		//Recieve DATA
 53a:	28 d0       	rcall	.+80     	; 0x58c <Serial_RX>
	cpi		DATA,'$'		// check first character '$' of the protocol UBX
 53c:	44 32       	cpi	r20, 0x24	; 36
	brne	getStringLoop	// if not, ask again
 53e:	e9 f7       	brne	.-6      	; 0x53a <getStringLoop>
	st		Z+,DATA			// store data
 540:	41 93       	st	Z+, r20
	rcall	Serial_TX		// Echo DATA
 542:	2d d0       	rcall	.+90     	; 0x59e <Serial_TX>

00000544 <getUBXLoop2>:
getUBXLoop2:
	rcall	Serial_RX		//Recieve DATA
 544:	23 d0       	rcall	.+70     	; 0x58c <Serial_RX>
	cpi		DATA,10			// check Line Feed for end of UBX protocol
 546:	4a 30       	cpi	r20, 0x0A	; 10
	breq	getStringEnd	// if not, keep receiving ubx data
 548:	19 f0       	breq	.+6      	; 0x550 <getStringEnd>
	st		Z+,DATA			//and store it
 54a:	41 93       	st	Z+, r20
	rcall	Serial_TX		// Echo DATA
 54c:	28 d0       	rcall	.+80     	; 0x59e <Serial_TX>
	rjmp	getUBXLoop2		//Receive it again until LineFeed
 54e:	fa cf       	rjmp	.-12     	; 0x544 <getUBXLoop2>

00000550 <getStringEnd>:
getStringEnd:
	st		Z+,DATA			// store last character of UBX protocol (Carry Return)
 550:	41 93       	st	Z+, r20
	rcall	Serial_TX		// Echo DATA
 552:	25 d0       	rcall	.+74     	; 0x59e <Serial_TX>

	pop		ZL
 554:	ef 91       	pop	r30
	pop		ZH
 556:	ff 91       	pop	r31
	pop		DATA
 558:	4f 91       	pop	r20
	pop		TEMP
 55a:	0f 91       	pop	r16
	ret
 55c:	08 95       	ret

0000055e <GPS_lookForFix>:
      D2 Differential 2D solution
      D3 Differential 3D solution
      RK Combined GPS + dead reckoning solution
      TT Time only solution  */
GPS_lookForFix:
	push	DATA
 55e:	4f 93       	push	r20
	push	ZH
 560:	ff 93       	push	r31
	push	ZL
 562:	ef 93       	push	r30
	push	COUNTER
 564:	3f 93       	push	r19

	ldi		ZH,hi8(buffer_gps_ubx)
 566:	f3 e0       	ldi	r31, 0x03	; 3
	ldi		ZL,lo8(buffer_gps_ubx)
 568:	e0 e0       	ldi	r30, 0x00	; 0
	ldi		COUNTER,8
 56a:	38 e0       	ldi	r19, 0x08	; 8

0000056c <lookForFixLoop>:
lookForFixLoop:
	ld		DATA,Z+
 56c:	41 91       	ld	r20, Z+
	cpi		DATA,','
 56e:	4c 32       	cpi	r20, 0x2C	; 44
	brne	lookForFixLoop
 570:	e9 f7       	brne	.-6      	; 0x56c <lookForFixLoop>
	dec		COUNTER
 572:	3a 95       	dec	r19
	brne	lookForFixLoop
 574:	d9 f7       	brne	.-10     	; 0x56c <lookForFixLoop>
	ld		DATA,Z
 576:	40 81       	ld	r20, Z
	cpi		DATA,'G'
 578:	47 34       	cpi	r20, 0x47	; 71
	brne	noFix
 57a:	11 f4       	brne	.+4      	; 0x580 <noFix>
	ldi		ANS,0
 57c:	80 e0       	ldi	r24, 0x00	; 0
	rjmp	lookForFixEnd
 57e:	01 c0       	rjmp	.+2      	; 0x582 <lookForFixEnd>

00000580 <noFix>:
noFix:
	ldi		ANS,1
 580:	81 e0       	ldi	r24, 0x01	; 1

00000582 <lookForFixEnd>:
lookForFixEnd:
	pop		COUNTER
 582:	3f 91       	pop	r19
	pop		ZL
 584:	ef 91       	pop	r30
	pop		ZH
 586:	ff 91       	pop	r31
	pop		DATA
 588:	4f 91       	pop	r20
	ret
 58a:	08 95       	ret

0000058c <Serial_RX>:
/*******************************************************************/
Serial_RX:
	push	TEMP
 58c:	0f 93       	push	r16

0000058e <RX_LOOP>:

RX_LOOP:
	lds		TEMP,UCSR0A
 58e:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
	sbrs	TEMP,RXC0
 592:	07 ff       	sbrs	r16, 7
	rjmp	RX_LOOP
 594:	fc cf       	rjmp	.-8      	; 0x58e <RX_LOOP>
	lds		DATA,UDR0
 596:	40 91 c6 00 	lds	r20, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>

	pop		TEMP
 59a:	0f 91       	pop	r16
	ret
 59c:	08 95       	ret

0000059e <Serial_TX>:

/*******************************************************************/
Serial_TX:
	push DATA
 59e:	4f 93       	push	r20
	push TEMP
 5a0:	0f 93       	push	r16

000005a2 <LOOP_TX>:

LOOP_TX:				// Wait for empty transmit buffer
	lds TEMP,UCSR0A		//Load into R17 from SRAM UCSR0A
 5a2:	00 91 c0 00 	lds	r16, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
	sbrs TEMP,UDRE0 	//Skip next instruction If Bit Register is set
 5a6:	05 ff       	sbrs	r16, 5
	rjmp LOOP_TX
 5a8:	fc cf       	rjmp	.-8      	; 0x5a2 <LOOP_TX>
	sts UDR0,DATA
 5aa:	40 93 c6 00 	sts	0x00C6, r20	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>

	pop TEMP
 5ae:	0f 91       	pop	r16
	pop DATA
 5b0:	4f 91       	pop	r20
 5b2:	08 95       	ret

000005b4 <SPI_transmit>:
}

//Enviar al SPI
unsigned char SPI_transmit(unsigned char data)
{
	SPDR = data;
 5b4:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<SPIF)));
 5b6:	0d b4       	in	r0, 0x2d	; 45
 5b8:	07 fe       	sbrs	r0, 7
 5ba:	fd cf       	rjmp	.-6      	; 0x5b6 <SPI_transmit+0x2>
	data = SPDR;
 5bc:	8e b5       	in	r24, 0x2e	; 46
	return(data);
}
 5be:	08 95       	ret

000005c0 <SPI_receive>:

//Recibir del SPI
unsigned char SPI_receive(void)
{
	unsigned char data;
	SPDR = 0xff;
 5c0:	8f ef       	ldi	r24, 0xFF	; 255
 5c2:	8e bd       	out	0x2e, r24	; 46
	while(!(SPSR & (1<<SPIF)));
 5c4:	0d b4       	in	r0, 0x2d	; 45
 5c6:	07 fe       	sbrs	r0, 7
 5c8:	fd cf       	rjmp	.-6      	; 0x5c4 <SPI_receive+0x4>
	data = SPDR;
 5ca:	8e b5       	in	r24, 0x2e	; 46
	return data;
}
 5cc:	08 95       	ret

000005ce <SD_sendCommand>:

	return 0; //successful return
}

unsigned char SD_sendCommand(unsigned char cmd, unsigned long arg)
{
 5ce:	cf 92       	push	r12
 5d0:	df 92       	push	r13
 5d2:	ef 92       	push	r14
 5d4:	ff 92       	push	r15
 5d6:	1f 93       	push	r17
 5d8:	cf 93       	push	r28
 5da:	df 93       	push	r29
 5dc:	18 2f       	mov	r17, r24
 5de:	6a 01       	movw	r12, r20
 5e0:	7b 01       	movw	r14, r22
	arg1 = arg;
	//SD card accepts byte address while SDHC accepts block address in multiples of 512
	//so, if it's SD card we need to convert block address into corresponding byte address by
	//multipying it with 512. which is equivalent to shifting it left 9 times
	//following 'if' loop does that
	if(SDHC_flag == 0)
 5e2:	80 91 82 03 	lds	r24, 0x0382	; 0x800382 <SDHC_flag>
 5e6:	81 11       	cpse	r24, r1
 5e8:	15 c0       	rjmp	.+42     	; 0x614 <SD_sendCommand+0x46>
	if(cmd == READ_SINGLE_BLOCK     ||
 5ea:	8f ee       	ldi	r24, 0xEF	; 239
 5ec:	81 0f       	add	r24, r17
 5ee:	82 30       	cpi	r24, 0x02	; 2
 5f0:	40 f0       	brcs	.+16     	; 0x602 <SD_sendCommand+0x34>
	cmd == READ_MULTIPLE_BLOCKS  ||
 5f2:	88 ee       	ldi	r24, 0xE8	; 232
 5f4:	81 0f       	add	r24, r17
 5f6:	82 30       	cpi	r24, 0x02	; 2
 5f8:	20 f0       	brcs	.+8      	; 0x602 <SD_sendCommand+0x34>
	cmd == WRITE_SINGLE_BLOCK    ||
	cmd == WRITE_MULTIPLE_BLOCKS ||
 5fa:	80 ee       	ldi	r24, 0xE0	; 224
 5fc:	81 0f       	add	r24, r17
 5fe:	82 30       	cpi	r24, 0x02	; 2
 600:	48 f4       	brcc	.+18     	; 0x614 <SD_sendCommand+0x46>
	cmd == ERASE_BLOCK_START_ADDR||
	cmd == ERASE_BLOCK_END_ADDR )
	{
		arg1 = arg1 << 9;
 602:	0b 2e       	mov	r0, r27
 604:	b9 e0       	ldi	r27, 0x09	; 9
 606:	cc 0c       	add	r12, r12
 608:	dd 1c       	adc	r13, r13
 60a:	ee 1c       	adc	r14, r14
 60c:	ff 1c       	adc	r15, r15
 60e:	ba 95       	dec	r27
 610:	d1 f7       	brne	.-12     	; 0x606 <SD_sendCommand+0x38>
 612:	b0 2d       	mov	r27, r0
	}
	SD_CS_ASSERT;
 614:	2a 98       	cbi	0x05, 2	; 5

	SPI_transmit(cmd | 0x40); //send command, first two bits always '01'
 616:	81 2f       	mov	r24, r17
 618:	80 64       	ori	r24, 0x40	; 64
 61a:	0e 94 da 02 	call	0x5b4	; 0x5b4 <SPI_transmit>
	SPI_transmit(arg1>>24);
 61e:	8f 2d       	mov	r24, r15
 620:	0e 94 da 02 	call	0x5b4	; 0x5b4 <SPI_transmit>
	SPI_transmit(arg1>>16);
 624:	8e 2d       	mov	r24, r14
 626:	0e 94 da 02 	call	0x5b4	; 0x5b4 <SPI_transmit>
	SPI_transmit(arg1>>8);
 62a:	8d 2d       	mov	r24, r13
 62c:	0e 94 da 02 	call	0x5b4	; 0x5b4 <SPI_transmit>
	SPI_transmit(arg1);
 630:	8c 2d       	mov	r24, r12
 632:	0e 94 da 02 	call	0x5b4	; 0x5b4 <SPI_transmit>

	if(cmd == SEND_IF_COND)	 //it is compulsory to send correct CRC for CMD8 (CRC=0x87) & CMD0 (CRC=0x95)
 636:	18 30       	cpi	r17, 0x08	; 8
 638:	21 f4       	brne	.+8      	; 0x642 <SD_sendCommand+0x74>
	SPI_transmit(0x87);    //for remaining commands, CRC is ignored in SPI mode
 63a:	87 e8       	ldi	r24, 0x87	; 135
 63c:	0e 94 da 02 	call	0x5b4	; 0x5b4 <SPI_transmit>
 640:	07 c0       	rjmp	.+14     	; 0x650 <SD_sendCommand+0x82>
	else
	SPI_transmit(0x95);
 642:	85 e9       	ldi	r24, 0x95	; 149
 644:	0e 94 da 02 	call	0x5b4	; 0x5b4 <SPI_transmit>
 648:	03 c0       	rjmp	.+6      	; 0x650 <SD_sendCommand+0x82>
 64a:	c1 50       	subi	r28, 0x01	; 1

	while((response = SPI_receive()) == 0xff) //wait response
	if(retry++ > 0xfe) break; //time out error
 64c:	11 f4       	brne	.+4      	; 0x652 <SD_sendCommand+0x84>
 64e:	1a c0       	rjmp	.+52     	; 0x684 <SD_sendCommand+0xb6>

	return 0; //successful return
}

unsigned char SD_sendCommand(unsigned char cmd, unsigned long arg)
{
 650:	c0 e0       	ldi	r28, 0x00	; 0
	if(cmd == SEND_IF_COND)	 //it is compulsory to send correct CRC for CMD8 (CRC=0x87) & CMD0 (CRC=0x95)
	SPI_transmit(0x87);    //for remaining commands, CRC is ignored in SPI mode
	else
	SPI_transmit(0x95);

	while((response = SPI_receive()) == 0xff) //wait response
 652:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <SPI_receive>
 656:	d8 2f       	mov	r29, r24
 658:	8f 3f       	cpi	r24, 0xFF	; 255
 65a:	b9 f3       	breq	.-18     	; 0x64a <SD_sendCommand+0x7c>
	if(retry++ > 0xfe) break; //time out error

	if(response == 0x00 && cmd == 58)  //checking response of CMD58
 65c:	81 11       	cpse	r24, r1
 65e:	12 c0       	rjmp	.+36     	; 0x684 <SD_sendCommand+0xb6>
 660:	1a 33       	cpi	r17, 0x3A	; 58
 662:	81 f4       	brne	.+32     	; 0x684 <SD_sendCommand+0xb6>
	{
		status = SPI_receive() & 0x40;     //first byte of the OCR register (bit 31:24)
 664:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <SPI_receive>
		if(status == 0x40) SDHC_flag = 1;  //we need it to verify SDHC card
 668:	86 ff       	sbrs	r24, 6
 66a:	04 c0       	rjmp	.+8      	; 0x674 <SD_sendCommand+0xa6>
 66c:	81 e0       	ldi	r24, 0x01	; 1
 66e:	80 93 82 03 	sts	0x0382, r24	; 0x800382 <SDHC_flag>
 672:	02 c0       	rjmp	.+4      	; 0x678 <SD_sendCommand+0xaa>
		else SDHC_flag = 0;
 674:	10 92 82 03 	sts	0x0382, r1	; 0x800382 <SDHC_flag>

		SPI_receive(); //remaining 3 bytes of the OCR register are ignored here
 678:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <SPI_receive>
		SPI_receive(); //one can use these bytes to check power supply limits of SD
 67c:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <SPI_receive>
		SPI_receive();
 680:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <SPI_receive>
	}

	SPI_receive(); //extra 8 CLK
 684:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <SPI_receive>
	SD_CS_DEASSERT;
 688:	2a 9a       	sbi	0x05, 2	; 5
	return response; //return state
}
 68a:	8d 2f       	mov	r24, r29
 68c:	df 91       	pop	r29
 68e:	cf 91       	pop	r28
 690:	1f 91       	pop	r17
 692:	ff 90       	pop	r15
 694:	ef 90       	pop	r14
 696:	df 90       	pop	r13
 698:	cf 90       	pop	r12
 69a:	08 95       	ret

0000069c <SD_initialization>:
void spi_init(void);
unsigned char SPI_transmit(unsigned char);
unsigned char SPI_receive(void);

unsigned char SD_initialization(void)
{
 69c:	0f 93       	push	r16
 69e:	1f 93       	push	r17
 6a0:	cf 93       	push	r28
 6a2:	df 93       	push	r29
 6a4:	1a e0       	ldi	r17, 0x0A	; 10
	unsigned char i, response, SD_version;
	unsigned int retry=0 ;
	for(i=0;i<10;i++)
	SPI_transmit(0xff);   //80 clock pulses spent before sending the first command
 6a6:	8f ef       	ldi	r24, 0xFF	; 255
 6a8:	0e 94 da 02 	call	0x5b4	; 0x5b4 <SPI_transmit>
 6ac:	11 50       	subi	r17, 0x01	; 1

unsigned char SD_initialization(void)
{
	unsigned char i, response, SD_version;
	unsigned int retry=0 ;
	for(i=0;i<10;i++)
 6ae:	d9 f7       	brne	.-10     	; 0x6a6 <SD_initialization+0xa>
	SPI_transmit(0xff);   //80 clock pulses spent before sending the first command
	SD_CS_ASSERT;
 6b0:	2a 98       	cbi	0x05, 2	; 5
	do
	{
		response = SD_sendCommand(GO_IDLE_STATE, 0); //send 'reset & go idle' command
 6b2:	40 e0       	ldi	r20, 0x00	; 0
 6b4:	50 e0       	ldi	r21, 0x00	; 0
 6b6:	ba 01       	movw	r22, r20
 6b8:	80 e0       	ldi	r24, 0x00	; 0
 6ba:	0e 94 e7 02 	call	0x5ce	; 0x5ce <SD_sendCommand>
 6be:	c0 e2       	ldi	r28, 0x20	; 32
 6c0:	d0 e0       	ldi	r29, 0x00	; 0
 6c2:	09 c0       	rjmp	.+18     	; 0x6d6 <SD_initialization+0x3a>
 6c4:	40 e0       	ldi	r20, 0x00	; 0
 6c6:	50 e0       	ldi	r21, 0x00	; 0
 6c8:	ba 01       	movw	r22, r20
 6ca:	80 e0       	ldi	r24, 0x00	; 0
 6cc:	0e 94 e7 02 	call	0x5ce	; 0x5ce <SD_sendCommand>
 6d0:	21 97       	sbiw	r28, 0x01	; 1
		retry++;
		if(retry>0x20)
 6d2:	09 f4       	brne	.+2      	; 0x6d6 <SD_initialization+0x3a>
 6d4:	63 c0       	rjmp	.+198    	; 0x79c <SD_initialization+0x100>
		return 1;   //time out, card not detected
	} while(response != 0x01);
 6d6:	81 30       	cpi	r24, 0x01	; 1
 6d8:	a9 f7       	brne	.-22     	; 0x6c4 <SD_initialization+0x28>

	SD_CS_DEASSERT;
 6da:	2a 9a       	sbi	0x05, 2	; 5
	SPI_transmit (0xff);
 6dc:	8f ef       	ldi	r24, 0xFF	; 255
 6de:	0e 94 da 02 	call	0x5b4	; 0x5b4 <SPI_transmit>
	SPI_transmit (0xff);
 6e2:	8f ef       	ldi	r24, 0xFF	; 255
 6e4:	0e 94 da 02 	call	0x5b4	; 0x5b4 <SPI_transmit>
	retry = 0;
	SD_version = 2; //default set to SD compliance with ver2.x;
	//this may change after checking the next command
	do
	{
		response = SD_sendCommand(SEND_IF_COND,0x000001AA); //Check power supply status, mendatory for SDHC card
 6e8:	4a ea       	ldi	r20, 0xAA	; 170
 6ea:	51 e0       	ldi	r21, 0x01	; 1
 6ec:	60 e0       	ldi	r22, 0x00	; 0
 6ee:	70 e0       	ldi	r23, 0x00	; 0
 6f0:	88 e0       	ldi	r24, 0x08	; 8
 6f2:	0e 94 e7 02 	call	0x5ce	; 0x5ce <SD_sendCommand>
 6f6:	ce ef       	ldi	r28, 0xFE	; 254
 6f8:	d0 e0       	ldi	r29, 0x00	; 0
 6fa:	0e c0       	rjmp	.+28     	; 0x718 <SD_initialization+0x7c>
 6fc:	4a ea       	ldi	r20, 0xAA	; 170
 6fe:	51 e0       	ldi	r21, 0x01	; 1
 700:	60 e0       	ldi	r22, 0x00	; 0
 702:	70 e0       	ldi	r23, 0x00	; 0
 704:	88 e0       	ldi	r24, 0x08	; 8
 706:	0e 94 e7 02 	call	0x5ce	; 0x5ce <SD_sendCommand>
 70a:	21 97       	sbiw	r28, 0x01	; 1
		retry++;
		if(retry>0xfe)
 70c:	29 f4       	brne	.+10     	; 0x718 <SD_initialization+0x7c>
		{
			SD_version = 1;
			cardType = 1;
 70e:	81 e0       	ldi	r24, 0x01	; 1
 710:	80 93 87 03 	sts	0x0387, r24	; 0x800387 <cardType>
	{
		response = SD_sendCommand(SEND_IF_COND,0x000001AA); //Check power supply status, mendatory for SDHC card
		retry++;
		if(retry>0xfe)
		{
			SD_version = 1;
 714:	01 e0       	ldi	r16, 0x01	; 1
			cardType = 1;
			break;
 716:	03 c0       	rjmp	.+6      	; 0x71e <SD_initialization+0x82>
		} //time out

	}while(response != 0x01);
 718:	81 30       	cpi	r24, 0x01	; 1
 71a:	81 f7       	brne	.-32     	; 0x6fc <SD_initialization+0x60>

	SD_CS_DEASSERT;
	SPI_transmit (0xff);
	SPI_transmit (0xff);
	retry = 0;
	SD_version = 2; //default set to SD compliance with ver2.x;
 71c:	02 e0       	ldi	r16, 0x02	; 2

	retry = 0;

	do
	{
		response = SD_sendCommand(APP_CMD,0); //CMD55, must be sent before sending any ACMD command
 71e:	40 e0       	ldi	r20, 0x00	; 0
 720:	50 e0       	ldi	r21, 0x00	; 0
 722:	ba 01       	movw	r22, r20
 724:	87 e3       	ldi	r24, 0x37	; 55
 726:	0e 94 e7 02 	call	0x5ce	; 0x5ce <SD_sendCommand>
		response = SD_sendCommand(SD_SEND_OP_COND,0x40000000); //ACMD41
 72a:	40 e0       	ldi	r20, 0x00	; 0
 72c:	50 e0       	ldi	r21, 0x00	; 0
 72e:	60 e0       	ldi	r22, 0x00	; 0
 730:	70 e4       	ldi	r23, 0x40	; 64
 732:	89 e2       	ldi	r24, 0x29	; 41
 734:	0e 94 e7 02 	call	0x5ce	; 0x5ce <SD_sendCommand>
 738:	ce ef       	ldi	r28, 0xFE	; 254
 73a:	d0 e0       	ldi	r29, 0x00	; 0
 73c:	0f c0       	rjmp	.+30     	; 0x75c <SD_initialization+0xc0>

	retry = 0;

	do
	{
		response = SD_sendCommand(APP_CMD,0); //CMD55, must be sent before sending any ACMD command
 73e:	40 e0       	ldi	r20, 0x00	; 0
 740:	50 e0       	ldi	r21, 0x00	; 0
 742:	ba 01       	movw	r22, r20
 744:	87 e3       	ldi	r24, 0x37	; 55
 746:	0e 94 e7 02 	call	0x5ce	; 0x5ce <SD_sendCommand>
		response = SD_sendCommand(SD_SEND_OP_COND,0x40000000); //ACMD41
 74a:	40 e0       	ldi	r20, 0x00	; 0
 74c:	50 e0       	ldi	r21, 0x00	; 0
 74e:	60 e0       	ldi	r22, 0x00	; 0
 750:	70 e4       	ldi	r23, 0x40	; 64
 752:	89 e2       	ldi	r24, 0x29	; 41
 754:	0e 94 e7 02 	call	0x5ce	; 0x5ce <SD_sendCommand>
 758:	21 97       	sbiw	r28, 0x01	; 1

		retry++;
		if(retry>0xfe)
 75a:	11 f1       	breq	.+68     	; 0x7a0 <SD_initialization+0x104>
		{
			return 2;  //time out, card initialization failed
		}

	}while(response != 0x00);
 75c:	81 11       	cpse	r24, r1
 75e:	ef cf       	rjmp	.-34     	; 0x73e <SD_initialization+0xa2>


	retry = 0;
	SDHC_flag = 0;
 760:	10 92 82 03 	sts	0x0382, r1	; 0x800382 <SDHC_flag>

	if (SD_version == 2)
 764:	02 30       	cpi	r16, 0x02	; 2
 766:	39 f5       	brne	.+78     	; 0x7b6 <SD_initialization+0x11a>
 768:	1d c0       	rjmp	.+58     	; 0x7a4 <SD_initialization+0x108>
	{
		do
		{
			response = SD_sendCommand(READ_OCR,0);
 76a:	40 e0       	ldi	r20, 0x00	; 0
 76c:	50 e0       	ldi	r21, 0x00	; 0
 76e:	ba 01       	movw	r22, r20
 770:	8a e3       	ldi	r24, 0x3A	; 58
 772:	0e 94 e7 02 	call	0x5ce	; 0x5ce <SD_sendCommand>
 776:	21 97       	sbiw	r28, 0x01	; 1
			retry++;
			if(retry>0xfe)
 778:	19 f4       	brne	.+6      	; 0x780 <SD_initialization+0xe4>
			{
				cardType = 0;
 77a:	10 92 87 03 	sts	0x0387, r1	; 0x800387 <cardType>
				break;
 77e:	02 c0       	rjmp	.+4      	; 0x784 <SD_initialization+0xe8>
			} //time out

		}while(response != 0x00);
 780:	81 11       	cpse	r24, r1
 782:	f3 cf       	rjmp	.-26     	; 0x76a <SD_initialization+0xce>

		if(SDHC_flag == 1) cardType = 2;
 784:	80 91 82 03 	lds	r24, 0x0382	; 0x800382 <SDHC_flag>
 788:	81 30       	cpi	r24, 0x01	; 1
 78a:	21 f4       	brne	.+8      	; 0x794 <SD_initialization+0xf8>
 78c:	82 e0       	ldi	r24, 0x02	; 2
 78e:	80 93 87 03 	sts	0x0387, r24	; 0x800387 <cardType>
 792:	11 c0       	rjmp	.+34     	; 0x7b6 <SD_initialization+0x11a>
		else cardType = 3;
 794:	83 e0       	ldi	r24, 0x03	; 3
 796:	80 93 87 03 	sts	0x0387, r24	; 0x800387 <cardType>
 79a:	0d c0       	rjmp	.+26     	; 0x7b6 <SD_initialization+0x11a>
	do
	{
		response = SD_sendCommand(GO_IDLE_STATE, 0); //send 'reset & go idle' command
		retry++;
		if(retry>0x20)
		return 1;   //time out, card not detected
 79c:	11 e0       	ldi	r17, 0x01	; 1
 79e:	0b c0       	rjmp	.+22     	; 0x7b6 <SD_initialization+0x11a>
		response = SD_sendCommand(SD_SEND_OP_COND,0x40000000); //ACMD41

		retry++;
		if(retry>0xfe)
		{
			return 2;  //time out, card initialization failed
 7a0:	12 e0       	ldi	r17, 0x02	; 2
 7a2:	09 c0       	rjmp	.+18     	; 0x7b6 <SD_initialization+0x11a>

	if (SD_version == 2)
	{
		do
		{
			response = SD_sendCommand(READ_OCR,0);
 7a4:	40 e0       	ldi	r20, 0x00	; 0
 7a6:	50 e0       	ldi	r21, 0x00	; 0
 7a8:	ba 01       	movw	r22, r20
 7aa:	8a e3       	ldi	r24, 0x3A	; 58
 7ac:	0e 94 e7 02 	call	0x5ce	; 0x5ce <SD_sendCommand>
 7b0:	ce ef       	ldi	r28, 0xFE	; 254
 7b2:	d0 e0       	ldi	r29, 0x00	; 0
 7b4:	e5 cf       	rjmp	.-54     	; 0x780 <SD_initialization+0xe4>
	//SD_sendCommand(CRC_ON_OFF, OFF); //disable CRC; deafault - CRC disabled in SPI mode
	//SD_sendCommand(SET_BLOCK_LEN, 512); //set block size to 512; default size is 512


	return 0; //successful return
}
 7b6:	81 2f       	mov	r24, r17
 7b8:	df 91       	pop	r29
 7ba:	cf 91       	pop	r28
 7bc:	1f 91       	pop	r17
 7be:	0f 91       	pop	r16
 7c0:	08 95       	ret

000007c2 <SD_writeSingleBlock>:
	data = SPDR;
	return data;
}

unsigned char SD_writeSingleBlock(unsigned long startBlock, unsigned char* buff)
{
 7c2:	0f 93       	push	r16
 7c4:	1f 93       	push	r17
 7c6:	cf 93       	push	r28
 7c8:	df 93       	push	r29
 7ca:	8a 01       	movw	r16, r20
	unsigned char response;
	unsigned int i, retry=0;
	response = SD_sendCommand(WRITE_SINGLE_BLOCK, startBlock); //write a Block command
 7cc:	ab 01       	movw	r20, r22
 7ce:	bc 01       	movw	r22, r24
 7d0:	88 e1       	ldi	r24, 0x18	; 24
 7d2:	0e 94 e7 02 	call	0x5ce	; 0x5ce <SD_sendCommand>
	
	if(response != 0x00) return response; //check for SD status: 0x00 - OK (No flags set)
 7d6:	81 11       	cpse	r24, r1
 7d8:	39 c0       	rjmp	.+114    	; 0x84c <SD_writeSingleBlock+0x8a>

	SD_CS_ASSERT;
 7da:	2a 98       	cbi	0x05, 2	; 5

	SPI_transmit(0xfe);     //Send start block token 0xfe (0x11111110)
 7dc:	8e ef       	ldi	r24, 0xFE	; 254
 7de:	0e 94 da 02 	call	0x5b4	; 0x5b4 <SPI_transmit>
 7e2:	e8 01       	movw	r28, r16
 7e4:	1e 5f       	subi	r17, 0xFE	; 254

	for(i=0; i<512; i++)    //send 512 bytes data
	SPI_transmit(buff[i]);
 7e6:	89 91       	ld	r24, Y+
 7e8:	0e 94 da 02 	call	0x5b4	; 0x5b4 <SPI_transmit>

	SD_CS_ASSERT;

	SPI_transmit(0xfe);     //Send start block token 0xfe (0x11111110)

	for(i=0; i<512; i++)    //send 512 bytes data
 7ec:	c0 17       	cp	r28, r16
 7ee:	d1 07       	cpc	r29, r17
 7f0:	d1 f7       	brne	.-12     	; 0x7e6 <SD_writeSingleBlock+0x24>
	SPI_transmit(buff[i]);

	SPI_transmit(0xff);     //transmit dummy CRC (16-bit), CRC is ignored here
 7f2:	8f ef       	ldi	r24, 0xFF	; 255
 7f4:	0e 94 da 02 	call	0x5b4	; 0x5b4 <SPI_transmit>
	SPI_transmit(0xff);
 7f8:	8f ef       	ldi	r24, 0xFF	; 255
 7fa:	0e 94 da 02 	call	0x5b4	; 0x5b4 <SPI_transmit>

	response = SPI_receive();
 7fe:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <SPI_receive>

	if( (response & 0x1f) != 0x05) //response= 0xXXX0AAA1 ; AAA='010' - data accepted
 802:	98 2f       	mov	r25, r24
 804:	9f 71       	andi	r25, 0x1F	; 31
 806:	95 30       	cpi	r25, 0x05	; 5
 808:	39 f0       	breq	.+14     	; 0x818 <SD_writeSingleBlock+0x56>
	{                              //AAA='101'-data rejected due to CRC error
		SD_CS_DEASSERT;              //AAA='110'-data rejected due to write error
 80a:	2a 9a       	sbi	0x05, 2	; 5
		return response;
 80c:	1f c0       	rjmp	.+62     	; 0x84c <SD_writeSingleBlock+0x8a>
	}

	while(!SPI_receive()) //wait for SD card to complete writing and get idle
	if(retry++ > 0xfffe){SD_CS_DEASSERT; return 1;}
 80e:	21 96       	adiw	r28, 0x01	; 1
 810:	29 f4       	brne	.+10     	; 0x81c <SD_writeSingleBlock+0x5a>
 812:	2a 9a       	sbi	0x05, 2	; 5
 814:	81 e0       	ldi	r24, 0x01	; 1
 816:	1a c0       	rjmp	.+52     	; 0x84c <SD_writeSingleBlock+0x8a>
 818:	c0 e0       	ldi	r28, 0x00	; 0
 81a:	d0 e0       	ldi	r29, 0x00	; 0
	{                              //AAA='101'-data rejected due to CRC error
		SD_CS_DEASSERT;              //AAA='110'-data rejected due to write error
		return response;
	}

	while(!SPI_receive()) //wait for SD card to complete writing and get idle
 81c:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <SPI_receive>
 820:	88 23       	and	r24, r24
 822:	a9 f3       	breq	.-22     	; 0x80e <SD_writeSingleBlock+0x4c>
	if(retry++ > 0xfffe){SD_CS_DEASSERT; return 1;}

	SD_CS_DEASSERT;
 824:	2a 9a       	sbi	0x05, 2	; 5
	SPI_transmit(0xff);   //just spend 8 clock cycle delay before reasserting the CS line
 826:	8f ef       	ldi	r24, 0xFF	; 255
 828:	0e 94 da 02 	call	0x5b4	; 0x5b4 <SPI_transmit>
	SD_CS_ASSERT;         //re-asserting the CS line to verify if card is still busy
 82c:	2a 98       	cbi	0x05, 2	; 5

	while(!SPI_receive()) //wait for SD card to complete writing and get idle
 82e:	08 c0       	rjmp	.+16     	; 0x840 <SD_writeSingleBlock+0x7e>
	if(retry++ > 0xfffe){SD_CS_DEASSERT; return 1;}
 830:	ce 01       	movw	r24, r28
 832:	01 96       	adiw	r24, 0x01	; 1
 834:	21 96       	adiw	r28, 0x01	; 1
 836:	19 f4       	brne	.+6      	; 0x83e <SD_writeSingleBlock+0x7c>
 838:	2a 9a       	sbi	0x05, 2	; 5
 83a:	81 e0       	ldi	r24, 0x01	; 1
 83c:	07 c0       	rjmp	.+14     	; 0x84c <SD_writeSingleBlock+0x8a>
 83e:	ec 01       	movw	r28, r24

	SD_CS_DEASSERT;
	SPI_transmit(0xff);   //just spend 8 clock cycle delay before reasserting the CS line
	SD_CS_ASSERT;         //re-asserting the CS line to verify if card is still busy

	while(!SPI_receive()) //wait for SD card to complete writing and get idle
 840:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <SPI_receive>
 844:	88 23       	and	r24, r24
 846:	a1 f3       	breq	.-24     	; 0x830 <SD_writeSingleBlock+0x6e>
	if(retry++ > 0xfffe){SD_CS_DEASSERT; return 1;}
	SD_CS_DEASSERT;
 848:	2a 9a       	sbi	0x05, 2	; 5
	
	return 0;
 84a:	80 e0       	ldi	r24, 0x00	; 0
}
 84c:	df 91       	pop	r29
 84e:	cf 91       	pop	r28
 850:	1f 91       	pop	r17
 852:	0f 91       	pop	r16
 854:	08 95       	ret

00000856 <SD_readSingleBlock>:

unsigned char SD_readSingleBlock(unsigned long startBlock, unsigned char* buff)
{
 856:	0f 93       	push	r16
 858:	1f 93       	push	r17
 85a:	cf 93       	push	r28
 85c:	df 93       	push	r29
 85e:	8a 01       	movw	r16, r20
	unsigned char response;
	unsigned int i, retry=0;

	response = SD_sendCommand(READ_SINGLE_BLOCK, startBlock); //read a Block command
 860:	ab 01       	movw	r20, r22
 862:	bc 01       	movw	r22, r24
 864:	81 e1       	ldi	r24, 0x11	; 17
 866:	0e 94 e7 02 	call	0x5ce	; 0x5ce <SD_sendCommand>
	
	if(response != 0x00) return response; //check for SD status: 0x00 - OK (No flags set)
 86a:	81 11       	cpse	r24, r1
 86c:	1d c0       	rjmp	.+58     	; 0x8a8 <SD_readSingleBlock+0x52>

	SD_CS_ASSERT;
 86e:	2a 98       	cbi	0x05, 2	; 5

	retry = 0;
	while(SPI_receive() != 0xfe) //wait for start block token 0xfe (0x11111110)
 870:	c0 e0       	ldi	r28, 0x00	; 0
 872:	d0 e0       	ldi	r29, 0x00	; 0
 874:	05 c0       	rjmp	.+10     	; 0x880 <SD_readSingleBlock+0x2a>
 876:	21 97       	sbiw	r28, 0x01	; 1
	if(retry++ > 0xfffe){SD_CS_DEASSERT; return 1;} //return if time-out
 878:	19 f4       	brne	.+6      	; 0x880 <SD_readSingleBlock+0x2a>
 87a:	2a 9a       	sbi	0x05, 2	; 5
 87c:	81 e0       	ldi	r24, 0x01	; 1
 87e:	14 c0       	rjmp	.+40     	; 0x8a8 <SD_readSingleBlock+0x52>
	if(response != 0x00) return response; //check for SD status: 0x00 - OK (No flags set)

	SD_CS_ASSERT;

	retry = 0;
	while(SPI_receive() != 0xfe) //wait for start block token 0xfe (0x11111110)
 880:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <SPI_receive>
 884:	8e 3f       	cpi	r24, 0xFE	; 254
 886:	b9 f7       	brne	.-18     	; 0x876 <SD_readSingleBlock+0x20>
 888:	e8 01       	movw	r28, r16
 88a:	1e 5f       	subi	r17, 0xFE	; 254
	if(retry++ > 0xfffe){SD_CS_DEASSERT; return 1;} //return if time-out

	for(i=0; i<512; i++) //read 512 bytes
	buff[i] = SPI_receive();
 88c:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <SPI_receive>
 890:	89 93       	st	Y+, r24

	retry = 0;
	while(SPI_receive() != 0xfe) //wait for start block token 0xfe (0x11111110)
	if(retry++ > 0xfffe){SD_CS_DEASSERT; return 1;} //return if time-out

	for(i=0; i<512; i++) //read 512 bytes
 892:	c0 17       	cp	r28, r16
 894:	d1 07       	cpc	r29, r17
 896:	d1 f7       	brne	.-12     	; 0x88c <SD_readSingleBlock+0x36>
	buff[i] = SPI_receive();

	SPI_receive(); //receive incoming CRC (16-bit), CRC is ignored here
 898:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <SPI_receive>
	SPI_receive();
 89c:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <SPI_receive>

	SPI_receive(); //extra 8 clock pulses
 8a0:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <SPI_receive>
	SD_CS_DEASSERT;
 8a4:	2a 9a       	sbi	0x05, 2	; 5

	return 0;
 8a6:	80 e0       	ldi	r24, 0x00	; 0
 8a8:	df 91       	pop	r29
 8aa:	cf 91       	pop	r28
 8ac:	1f 91       	pop	r17
 8ae:	0f 91       	pop	r16
 8b0:	08 95       	ret

000008b2 <_exit>:
 8b2:	f8 94       	cli

000008b4 <__stop_program>:
 8b4:	ff cf       	rjmp	.-2      	; 0x8b4 <__stop_program>
